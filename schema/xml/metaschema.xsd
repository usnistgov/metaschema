<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
  attributeFormDefault="unqualified" xmlns="http://csrc.nist.gov/ns/oscal/metaschema/1.0"
  targetNamespace="http://csrc.nist.gov/ns/oscal/metaschema/1.0">

  <xs:include schemaLocation="metaschema-prose-module.xsd">
    <xs:annotation>
      <xs:documentation>This prose module provides support for line and multiline markup.</xs:documentation>
    </xs:annotation>
  </xs:include>

  <xs:include schemaLocation="metaschema-datatypes.xsd">
    <xs:annotation>
      <xs:documentation>This data types module provides support for all other built-in Metaschema data types.</xs:documentation>
    </xs:annotation>
  </xs:include>

  <xs:element name="METASCHEMA">
    <xs:annotation>
      <xs:documentation>Root element of a Metaschema definition. Defines a family of data
        structures representing a model.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="schema-name" type="MarkupLineDatatype">
          <xs:annotation>
            <xs:documentation>The name of the information model represented by this Metaschema definition.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="schema-version" type="VersionType"/>
        <xs:element name="short-name" type="ShortNameType"/>
        <xs:element name="namespace" type="URIDatatype">
          <xs:annotation>
            <xs:documentation>The namespace for the collection of Metaschema models this Metaschema module
              belongs to. Also the XML namespace governing the names of elements in XML documents, which
              expect to be conformant to the schemas expressed by this Metaschema module. By using this
              namespace, documents and document fragments used in mixed-format environments may be
              distinguished from neighbor XML formats using other namespaces. This value is not reflected in
              Metaschema JSON.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="json-base-uri" type="JsonBaseUriType"/>
        <xs:element name="prop" type="PropertyType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="remarks" type="RemarksType" minOccurs="0"/>

        <xs:element name="import" type="MetaschemaImportType" minOccurs="0" maxOccurs="unbounded"/>

		<xs:element name="namespace-binding" type="NamespaceBindingType" minOccurs="0" maxOccurs="unbounded"/> 

        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element name="define-assembly" type="GlobalAssemblyDefinitionType"/>
          <xs:element name="define-field" type="GlobalFieldDefinitionType"/>
          <xs:element name="define-flag" type="GlobalFlagDefinitionType"/>
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="abstract" type="YesNoType" default="no"/>
    </xs:complexType>
    <xs:unique name="unique-constraint-ids">
      <xs:selector
        xpath=".//allowed-values | .//matches | .//index-has-key | .//is-unique | .//has-cardinality | .//expect | .//index"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:key name="key-index-constraint">
      <xs:selector xpath=".//index"/>
      <xs:field xpath="@name"/>
    </xs:key>
    <!--    <xs:keyref name="keyref-index-has-key" refer="key-index-constraint">
      <xs:selector xpath=".//m:index-has-key"/>
      <xs:field xpath="@name"/>
    </xs:keyref>
-->
  </xs:element>

  <xs:complexType name="MetaschemaImportType">
    <xs:annotation>
      <xs:documentation>Imports a set of Metaschema modules containing exported definitions from an out-of-line resource, supporting reuse of common information structures.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="href" type="URIReferenceDatatype" use="required">
      <xs:annotation>
        <xs:documentation>A relative or absolute URI for retrieving an out-of-line Metaschema definition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="NamespaceBindingType">
  	<xs:annotation>
      <xs:documentation>Assigns a Metapath namespace to a prefix for use in a Metapath expression in a lexical qualified name.</xs:documentation>
  	</xs:annotation>
	<xs:attribute name="prefix" type="TokenDatatype" use="required">
      <xs:annotation>
        <xs:documentation>The prefix that is bound to the namespace.</xs:documentation>
      </xs:annotation>
	</xs:attribute>
	<xs:attribute name="uri" type="URIDatatype" use="required">
      <xs:annotation>
        <xs:documentation>The namespace URI to bind to the prefix.</xs:documentation>
      </xs:annotation>
	</xs:attribute>
  </xs:complexType>

  <xs:group name="DefinitionMetadataGroup">
    <xs:sequence>
      <xs:element name="formal-name" minOccurs="0">
        <xs:simpleType>
          <xs:annotation>
            <xs:documentation>A formal name for the data construct for use in documentation.</xs:documentation>
          </xs:annotation>
          <xs:restriction base="StringDatatype"/>
        </xs:simpleType>
      </xs:element>
      <xs:element name="description" type="MarkupLineDatatype" minOccurs="0">
        <xs:annotation>
          <xs:documentation>A short semantic description of the data construct's purpose.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="prop" type="PropertyType" minOccurs="0" maxOccurs="unbounded"/>
      <!--
        When using:
        <prop name="value-type" value="identifier"/>

        The "identifier-type" must be one of:
        <prop name="identifier-type" value="machine-oriented"/>
        <prop name="identifier-type" value="human-oriented"/>
        
        Multiple instances of "identifier-type" can be used to support both cases.

        TODO: Need to update the documentation to clarify that the value set is constrained and what the options are.

        The "identifier-uniqueness" must be one of:
        <prop name="identifier-uniqueness" value="global"/> - for a globally unique identifier (i.e., UUID)
        <prop name="identifier-uniqueness" value="local-instance"/> - for an identifier that is unqiue within the containing instance

        The "identifier-scope" must be one of:
        <prop name="identifier-scope" value="instance"/>
        <prop name="identifier-scope" value="cross-instance"/>

        Must be one of:
        <prop name="identifier-persistence" value="per-subject"/>
        <prop name="identifier-persistence" value="change-on-write"/>
     -->
     <!--
        When using:
        <prop name="value-type" value="identifier-reference"/>

        The "identifier-type" must be one of:
        <prop name="identifier-type" value="machine-oriented"/>
        <prop name="identifier-type" value="human-oriented"/>
        
        Multiple instances of "identifier-type" can be used to support both cases.

        TODO: Need to update the documentation to clarify that the value set is constrained and what the options are.

        The "identifier-scope" must be one of:
        <prop name="identifier-reference-scope" value="instance"/>
        <prop name="identifier-reference-scope" value="cross-instance"/>

        Must be one of:
        <prop namespace="http://csrc.nist.gov/ns/oscal" name="identifier-reference-model" value="model-name"/>
     -->       
    </xs:sequence>
  </xs:group>

  <xs:complexType name="PropertyType">
    <xs:attribute name="namespace" type="URIDatatype"
      default="http://csrc.nist.gov/ns/oscal/metaschema/1.0"/>
    <xs:attribute name="name" type="TokenDatatype" use="required"/>
    <xs:attribute name="value" type="TokenDatatype" use="required"/>
  </xs:complexType>

  <xs:simpleType name="ModelNameType">
    <xs:annotation>
      <xs:documentation>The human-oriented naming type for all definitions and instances for use in textual data.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TokenDatatype"/>
  </xs:simpleType>

  <xs:simpleType name="ModelIndexType">
    <xs:annotation>
      <xs:documentation>The machine-oriented naming type of all definitions and instances for use in binary data.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="IntegerDatatype"/>
  </xs:simpleType>

  <xs:attributeGroup name="DefinitionNamingGroup">
    <xs:annotation>
      <xs:documentation>Common definition attributes that support definition naming.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" use="required" type="ModelNameType"/>
    <xs:attribute name="index" use="optional" type="ModelIndexType"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="DefinitionReferenceNamingGroup">
    <xs:annotation>
      <xs:documentation>Common definition attributes that support definition referencing.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ref" use="required" type="ModelNameType"/>
    <xs:attribute name="index" use="optional" type="ModelIndexType"/>
  </xs:attributeGroup>

  <xs:group name="RootDefinitionNamingGroup">
    <xs:annotation>
      <xs:documentation>Common definition attributes that support root definition naming.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="root-name">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="ModelNameType">
              <xs:attribute name="index" use="optional" type="ModelIndexType"/>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="UseNameType">
    <xs:simpleContent>
      <xs:extension base="ModelNameType">
        <xs:attribute name="index" use="optional" type="ModelIndexType"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:group name="UseNamingGroup">
    <xs:annotation>
      <xs:documentation>Common definition attributes that support instance naming.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="use-name" type="UseNameType" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="GlobalAssemblyDefinitionType">
    <xs:annotation>
      <xs:documentation>An element with structured element content in XML; in JSON, an object with
        properties. Defined globally, an assembly can be assigned to appear in the <code>model</code> of any assembly (another assembly type, or itself), by <code>assembly</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:choice minOccurs="0">
        <xs:group ref="RootDefinitionNamingGroup"/>
        <xs:group ref="UseNamingGroup"/>
      </xs:choice>
      <xs:element name="json-key" type="JsonKeyType" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="model" type="AssemblyModelType" minOccurs="0"/>
      <xs:element name="constraint" type="DefineAssemblyConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attribute name="scope" type="ScopeType" default="global"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="AssemblyModelType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="assembly" type="AssemblyReferenceType"/>
        <xs:element name="field" type="FieldReferenceType"/>
        <xs:element name="define-assembly" type="InlineAssemblyDefinitionType"/>
        <xs:element name="define-field" type="InlineFieldDefinitionType"/>
        <xs:element name="choice" type="ChoiceType"/>
        <xs:element name="choice-group" type="GroupedChoiceType"/>
      </xs:choice>
      <xs:element name="any" type="AnyType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:group name="JsonValueKeyChoiceGroup">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element name="json-value-key" type="JsonValueKeyType"/>
        <xs:element name="json-value-key-flag" type="JsonValueKeyFlagType"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:simpleType name="JsonValueKeyType">
    <xs:annotation>
      <xs:documentation>Used inside a field definition, designates a name (key) for the property in JSON containing the field's value. Use of a 'json-value-key' is mutually exclusive with a 'json-value-key-flag'.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="ModelNameType"/>
  </xs:simpleType>
  <xs:complexType name="JsonValueKeyFlagType">
    <xs:annotation>
      <xs:documentation>Used inside a field definition, designates a flag whose value is to be used as the name (key)  for the property in JSON containing the field's value. Use of a 'json-value-key-flag' is mutually exclusive with a 'json-value-key'.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="flag-ref" type="ModelNameType"/>
  </xs:complexType>

  <xs:complexType name="GlobalFieldDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or markup
        content. Defined globally, a field can be assigned to appear in the <code>model</code> of any assembly by <code>field</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="UseNamingGroup"/>
      <xs:element name="json-key" type="JsonKeyType" minOccurs="0"/>
      <xs:group ref="JsonValueKeyChoiceGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="constraint" type="DefineFieldConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="FieldValueAttributeGroup"/>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attribute name="scope" type="ScopeType" default="global"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="GlobalFlagDefinitionType">
    <xs:annotation>
      <xs:documentation>A data point to be expressed as an attribute in the XML or a name/value pair
        in the JSON. A flag may also be defined implicitly with the assembly or field to which it
        applies. Defined globally, a flag can be assigned to any field or assembly by <code>flag</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="UseNamingGroup"/>
      <xs:element name="constraint" minOccurs="0" type="DefineFlagConstraintsType"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attributeGroup ref="FlagValueAttributeGroup"/>
    <xs:attribute name="scope" type="ScopeType" default="global"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="InlineAssemblyDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or markup
        content. A local definition describes and constrains the appearance of the field only in this (assembly) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:element name="json-key" type="JsonKeyType" minOccurs="0"/>
      <xs:group ref="JsonValueKeyChoiceGroup"/>
      <xs:element name="group-as" type="GroupAsType" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="model" type="AssemblyModelType" minOccurs="0"/>
      <xs:element name="constraint" type="DefineAssemblyConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="CardinalitySpecificationGroup"/>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="InlineFieldDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or markup
        content.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:element name="json-key" type="JsonKeyType" minOccurs="0"/>
      <xs:group ref="JsonValueKeyChoiceGroup"/>
      <xs:element name="group-as" type="GroupAsType" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="constraint" type="DefineFieldConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="FieldValueAttributeGroup"/>
    <xs:attribute name="collapsible" type="YesNoType" default="no"/>
    <xs:attributeGroup ref="CardinalitySpecificationGroup"/>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attribute name="in-xml" type="InXmlWrappedType" default="WRAPPED">
      <xs:annotation>
        <xs:documentation>A field with assigned data type 'markup-multiline' may be designated for representation with or without a containing (wrapper) element in XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="InlineFlagDefinitionType">
    <xs:annotation>
      <xs:documentation>A data point to be expressed as an attribute in the XML or a name/value pair in the JSON. A local definition describes and constrains the appearance of the flag only in its parent (assembly or field) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:element name="constraint" minOccurs="0" type="DefineFlagConstraintsType"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attributeGroup ref="FlagValueAttributeGroup"/>
    <xs:attribute name="required" type="YesNoType" default="no"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:simpleType name="JsonBaseUriType">
    <xs:annotation>
      <xs:documentation>The JSON Base URI is nominal base URI assigned to a JSON Schema instance expressing the model defined by this Metaschema module.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="URIDatatype"/>
  </xs:simpleType>

  <xs:complexType name="RemarksType">
    <xs:annotation>
      <xs:documentation>Any explanatory or helpful information to be provided in the
        documentation of an assembly, field or flag.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="MarkupMultilineDatatype">
        <xs:attribute name="class">
          <xs:annotation>
            <xs:documentation>Mark as 'XML' for XML-only or 'JSON' for JSON-only remarks.</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:restriction base="TokenDatatype">
              <xs:enumeration value="XML">
                <xs:annotation>
                  <xs:documentation>The remark applies to only XML representations.</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="JSON">
                <xs:annotation>
                  <xs:documentation>The remark applies to only JSON and YAML representations.</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="VersionType">
    <xs:annotation>
      <xs:documentation>A version string used to distinguish between multiple revisions of the same resource.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="StringDatatype"/>
  </xs:simpleType>

  <xs:simpleType name="ShortNameType">
    <xs:annotation>
      <xs:documentation>A short (code) name to be used for the Metaschema module, for example as a constituent of names assigned to
        derived artifacts such as schemas and conversion utilities.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TokenDatatype"/>
  </xs:simpleType>

  <xs:complexType name="AssemblyReferenceType">
    <xs:annotation>
      <xs:documentation>Referencing an assembly definition to include an assembly or assemblies of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="UseNamingGroup"/>
      <xs:element name="group-as" type="GroupAsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionReferenceNamingGroup"/>
    <xs:attributeGroup ref="CardinalitySpecificationGroup"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="FieldReferenceType">
    <xs:annotation>
      <xs:documentation>Referencing a field definition to include a field or fields of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="UseNamingGroup"/>
      <xs:element name="group-as" type="GroupAsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionReferenceNamingGroup"/>
    <xs:attributeGroup ref="CardinalitySpecificationGroup"/>
    <xs:attribute name="in-xml" type="InXmlWrappedType" default="WRAPPED">
      <xs:annotation>
        <xs:documentation>A field with assigned data type 'markup-multiline' may be designated for representation with or without a containing (wrapper) element
          in XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default" type="StringDatatype"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:simpleType name="InXmlWrappedType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="WRAPPED">
        <xs:annotation>
          <xs:documentation>Any paragraph or block contents of a markup-multiline field will be represented with a containing (wrapper) element in the XML.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WITH_WRAPPER">
        <xs:annotation>
          <xs:documentation>(deprecated)Alias for WRAPPED.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNWRAPPED">
        <xs:annotation>
          <xs:documentation>With in-xml='UNWRAPPED', a field contents will be represented in the XML with no wrapper, so the field will be implicit. Among sibling fields in a given model, only one of them may be designated as UNWRAPPED.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:attributeGroup name="CardinalitySpecificationGroup">
    <xs:attribute name="min-occurs" type="NonNegativeIntegerDatatype" default="0">
      <xs:annotation>
        <xs:documentation>Minimum occurrence of assemblies or fields within a valid model. The default value is 0, for an optional occurrence.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-occurs" type="NaturalNumberOrUnboundedType" default="1">
      <xs:annotation>
        <xs:documentation>Maximum occurrence of assemblies or fields within a valid model. The default value is 1, for a single occurrence. 'unbounded' permits any number of assemblies of the designated type.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="FieldValueAttributeGroup">
    <xs:attribute name="as-type" type="FieldDatatypesType" default="string"/>
    <xs:attribute name="default" type="StringDatatype"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="FlagValueAttributeGroup">
    <!-- datatype should default to 'string' -->
    <xs:attribute name="as-type" type="SimpleDatatypesType" default="string"/>
    <xs:attribute name="default" type="StringDatatype"/>
  </xs:attributeGroup>

  <xs:simpleType name="NaturalNumberOrUnboundedType">
    <xs:union memberTypes="PositiveIntegerDatatype">
      <xs:simpleType>
        <xs:restriction base="StringDatatype">
          <xs:enumeration value="unbounded"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:attributeGroup name="DeprecationAttributeGroup">
    <xs:attribute name="deprecated" type="VersionType">
      <xs:annotation>
        <xs:documentation>The associated construct has been deprecated at the specified version. Its use should be avoided if possible.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="FlagReferenceType">
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="UseNamingGroup"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionReferenceNamingGroup"/>
    <xs:attribute name="required" type="YesNoType" default="no"/>
    <xs:attribute name="default" type="StringDatatype"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>

  <xs:complexType name="ChoiceType">
    <xs:annotation>
      <xs:documentation>Within a model, indicates that only one of a set of fields or assemblies, referenced in the choice, may occur in valid instances.</xs:documentation>
    </xs:annotation>
    <xs:choice maxOccurs="unbounded">
      <xs:element name="assembly" type="AssemblyReferenceType"/>
      <xs:element name="field" type="FieldReferenceType"/>
      <xs:element name="define-assembly" type="InlineAssemblyDefinitionType"/>
      <xs:element name="define-field" type="InlineFieldDefinitionType"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:complexType name="GroupedChoiceType">
    <xs:annotation>
      <xs:documentation>Within a model, indicates that only one of a set of fields or assemblies, referenced in the choice, may occur in valid instances.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="json-key" type="JsonKeyType" minOccurs="0"/>
      <xs:element name="group-as" type="GroupAsType"/>
      <xs:element name="discriminator" minOccurs="0" type="TokenDatatype" default="object-type"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="assembly" type="GroupedAssemblyReferenceType"/>
        <xs:element name="field" type="GroupedFieldReferenceType"/>
        <xs:element name="define-assembly" type="GroupedInlineAssemblyDefinitionType"/>
        <xs:element name="define-field" type="GroupedInlineFieldDefinitionType"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="min-occurs" type="NonNegativeIntegerDatatype" default="0">
      <xs:annotation>
        <xs:documentation>Minimum occurrence of assemblies or fields within a valid model. The default value is 0, for an optional occurrence.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-occurs" type="NaturalNumberOrUnboundedType" default="unbounded">
      <xs:annotation>
        <xs:documentation>Maximum occurrence of assemblies or fields within a valid model. The default value is 1, for a single occurrence. 'unbounded' permits any number of assemblies of the designated type.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  
  <xs:complexType name="GroupedAssemblyReferenceType">
    <xs:annotation>
      <xs:documentation>Referencing an assembly definition to include an assembly or assemblies of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="ChoiceUseNamingGroup"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="ref" use="required" type="ModelNameType"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>
  
  <xs:complexType name="GroupedFieldReferenceType">
    <xs:annotation>
      <xs:documentation>Referencing a field definition to include a field or fields of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="ChoiceUseNamingGroup"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="ref" use="required" type="ModelNameType"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>
  
  <xs:complexType name="GroupedInlineAssemblyDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or markup
        content. A local definition describes and constrains the appearance of the field only in this (assembly) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="ChoiceUseNamingGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="model" minOccurs="0" type="AssemblyModelType"/>
      <xs:element name="constraint" type="DefineAssemblyConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>
  
  <xs:complexType name="GroupedInlineFieldDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or markup
        content. A local definition describes and constrains the appearance of the field only in this (assembly) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
      <xs:group ref="ChoiceUseNamingGroup"/>
      <xs:group ref="JsonValueKeyChoiceGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="flag" type="FlagReferenceType"/>
        <xs:element name="define-flag" type="InlineFlagDefinitionType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:element name="constraint" type="DefineFieldConstraintsType" minOccurs="0"/>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:element name="example" type="ExampleType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="as-type" type="FieldDatatypesType" default="string"/>
    <xs:attribute name="collapsible" type="YesNoType" default="no"/>
    <xs:attributeGroup ref="DefinitionNamingGroup"/>
    <xs:attribute name="in-xml" type="InXmlWrappedType" default="WRAPPED">
      <xs:annotation>
        <xs:documentation>A field with assigned datatype 'markup-multiline' may be designated for representation with or without a containing (wrapper) element
          in XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="DeprecationAttributeGroup"/>
  </xs:complexType>
  <xs:group name="ChoiceUseNamingGroup">
    <xs:annotation>
      <xs:documentation>Common definition attributes that support instance naming.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="use-name" type="UseNameType" minOccurs="0"/>
      <xs:element name="discriminator-value" type="TokenDatatype" minOccurs="0"/>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="AnyType">
    <xs:annotation>
      <xs:documentation>Within a model, a foreign element may be permitted here.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="ExampleType">
    <xs:sequence>
      <xs:element name="description" type="MarkupLineDatatype" minOccurs="0">
        <xs:annotation>
          <xs:documentation>A short description providing basic documentation about the example's purpose.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:any namespace="##other" processContents="lax"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="href" type="URIReferenceDatatype"/>
    <xs:attribute name="path" type="StringDatatype"/>
  </xs:complexType>

  <xs:complexType name="JsonKeyType">
    <xs:annotation>
      <xs:documentation>In the XML, produces an attribute with the given name, whose value is used as a key value (aka object property name) in the JSON, enabling objects to be 'lifted' out of arrays when such values are distinct. Implies that siblings will never share values.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="flag-ref" type="ModelNameType" use="required"/>
  </xs:complexType>

  <xs:complexType name="GroupAsType">
    <xs:annotation>
      <xs:documentation>When a given referenced field or assembly must be wrapped in an outer grouping, these settings apply, including a name for the group, and how to express the grouping in the respective formats. Not necessary when a field or assembly has max-occurs='1'</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="ModelNameType" use="required"/>
    <xs:attribute name="in-json" type="JsonGroupAsBehaviorType" use="optional"
      default="SINGLETON_OR_ARRAY">
      <!-- TODO: change the default to "ARRAY" -->
      <xs:annotation>
        <xs:documentation>How to represent a grouping in JSON</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="in-xml" type="XmlGroupAsBehaviorType" use="optional" default="UNGROUPED">
      <xs:annotation>
        <xs:documentation>Whether to represent a grouping explicitly in XML</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="JsonGroupAsBehaviorType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="ARRAY">
        <xs:annotation>
          <xs:documentation>Always use an array</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SINGLETON_OR_ARRAY">
        <xs:annotation>
          <xs:documentation>Produce a singleton for a single member (field or assembly) or an array for multiple members</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BY_KEY">
        <xs:annotation>
          <xs:documentation>For any group (one or more members) produce an object with properties for each member, using a designated flag for their key (label) values, which must be distinct</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="XmlGroupAsBehaviorType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="GROUPED">
        <xs:annotation>
          <xs:documentation>Use a wrapper element</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNGROUPED">
        <xs:annotation>
          <xs:documentation>Do not use a wrapper element</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="SimpleDatatypesType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="base64"/>
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="date"/>
      <xs:enumeration value="date-time"/>
      <xs:enumeration value="date-time-with-timezone"/>
      <xs:enumeration value="date-with-timezone"/>
      <xs:enumeration value="day-time-duration"/>
      <xs:enumeration value="decimal"/>
      <!-- Not supporting float or double -->
      <!--<xs:enumeration value="float" />-->
      <!--<xs:enumeration value="double" />-->
      <xs:enumeration value="email-address"/>
      <xs:enumeration value="hostname"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="ip-v4-address"/>
      <xs:enumeration value="ip-v6-address"/>
      <xs:enumeration value="non-negative-integer"/>
      <xs:enumeration value="positive-integer"/>
      <xs:enumeration value="string">
        <xs:annotation>
          <xs:documentation>A string with no leading or trailing whitespace.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="token"/>
      <xs:enumeration value="uri"/>
      <xs:enumeration value="uri-reference"/>
      <xs:enumeration value="uuid"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="FieldDatatypesType">
    <xs:union memberTypes="SimpleDatatypesType">
      <xs:simpleType>
        <xs:restriction base="TokenDatatype">
          <!--<xs:enumeration value="empty"/>-->
          <xs:enumeration value="markup-line"/>
          <xs:enumeration value="markup-multiline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <!-- TODO: check if both forms are handled. In some cases only 'yes' is handled, and 'true' is not. -->
  <xs:simpleType name="YesNoType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="yes"/>
      <xs:enumeration value="no"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ScopeType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="local">
        <xs:annotation>
          <xs:documentation>This definition is only available in the context of the current Metaschema module.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="global">
        <xs:annotation>
          <xs:documentation>This definition will be made available to any Metaschema module that includes this one either directly or indirectly through a chain of imported Metaschema modules.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- ************************** -->
  <!-- * Metaschema Constraints * -->
  <!-- ************************** -->
  <xs:simpleType name="MetaschemaPathType">
    <xs:restriction base="StringDatatype"/>
  </xs:simpleType>
  
  <xs:complexType name="ConstraintType" abstract="true">
    <xs:sequence>
      <xs:group ref="DefinitionMetadataGroup"/>
    </xs:sequence>
    <xs:attribute name="id" type="TokenDatatype" use="optional"/>
    <xs:attribute name="level" type="ConstraintLevelType" default="ERROR"/>
  </xs:complexType>

  <xs:simpleType name="ConstraintLevelType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="CRITICAL">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a serious fault in the content
            that will prevent typical use of the content.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ERROR">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a fault in the content. This
            may include issues around compatibility, integrity, consistency, etc.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARNING">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a potential issue
            with the content.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="INFORMATIONAL">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a point of interest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DEBUG">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a fault in the content that may
            warrant review by a developer when performing model or tool development.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>      
    </xs:restriction>
  </xs:simpleType>
  
  <xs:group name="ConstraintContentsGroup">
    <xs:sequence>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="AllowedValuesType">
    <xs:annotation>
      <xs:documentation>Indicates an enumeration of a set values to be recognized for a flag or field.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="enum" type="AllowedValueType" minOccurs="1" maxOccurs="unbounded"/>
          <xs:group ref="ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="allow-other" type="YesNoType" default="no">
          <xs:annotation>
            <xs:documentation>The given enumerated value or values are inclusive of other values ('yes') or not ('no', the default)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="extensible" type="ExtensibleEnumType" default="external">
          <xs:annotation>
            <xs:documentation>Determines if the given enumerated values may be extended by other allowed value constraints.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="ExtensibleEnumType">
    <xs:restriction base="TokenDatatype">
      <xs:enumeration value="model">
        <xs:annotation>
          <xs:documentation>Can be extended by constraints within the same module.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="external">
        <xs:annotation>
          <xs:documentation>Can be extended by external constraints.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="none">
        <xs:annotation>
          <xs:documentation>Cannot be extended.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="AllowedValueType">
    <xs:annotation>
      <xs:documentation>An enumerated value for a flag or field. The value is indicated by the 'value' attribute while the element contents describe the intended semantics for documentation.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="MarkupLineDatatype">
        <xs:attribute name="value" use="required" type="StringDatatype">
          <xs:annotation>
            <xs:documentation>A value recognized for a flag or field.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="DeprecationAttributeGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="RegexType">
    <xs:annotation>
      <xs:documentation>A regular expression subset that conforms to both https://www.w3.org/TR/xmlschema11-2/#regexes and https://www.ecma-international.org/ecma-262/11.0/index.html#sec-patterns.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="StringDatatype"/>
  </xs:simpleType>

  <xs:complexType name="MatchesConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:group ref="ConstraintContentsGroup"/>
        </xs:sequence>
        <!-- TODO: need a rule to enforce that either a regex or a datatype is used; or make these element children and use a choice -->
        <xs:attribute name="regex" type="RegexType"/>
        <xs:attribute name="datatype" type="SimpleDatatypesType">
          <xs:annotation>
            <xs:documentation>Specifies the datatype for which the value identified by the scope
              attribute must conform to.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedMatchesConstraintType">
    <xs:complexContent>
      <xs:extension base="MatchesConstraintType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a Metaschema Metapath. If the value is "." and the containing Metaschema object is a field, the constraint applies to the field's value. Otherwise, the scope value "." is not allowed to be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedAllowedValuesConstraintType">
    <xs:complexContent>
      <xs:extension base="AllowedValuesType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a Metaschema Metapath. If the value is "." and the containing Metaschema object is a field, the constraint applies to the field's value.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IndexFieldType">
    <xs:sequence>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="target" type="MetaschemaPathType" use="required">
      <xs:annotation>
        <xs:documentation>Specifies the field or flag value that is used to generate the key for a given object that is a member of this index. If more than one key-field is provided, then the key is a composition of the specified key-field objects. The ordering of the key-field objects establish the relative order of the index's key. The field or flag values pointed to are a field or flag value, which can be an empty value if not provided. Note: Multiple empty values can result in key conflicts.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="KeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an unique key constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="key-field" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation>Specifies a value, relative to the provided <code>target</code>,
                that is to be used as part of the key. More than one key-field can be used to create
                a composite key.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:complexContent>
                <xs:extension base="IndexFieldType">
                  <xs:attribute name="pattern" type="RegexType">
                    <xs:annotation>
                      <xs:documentation>The first captured group in the regular expression is used
                        as the key value for lookup. The regular expression must not match a
                        zero-length string.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:extension>
              </xs:complexContent>
            </xs:complexType>
          </xs:element>
          <xs:group ref="ConstraintContentsGroup"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedKeyConstraintType">
    <xs:complexContent>
      <xs:extension base="KeyConstraintType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies a Metapath that can be evaluated to get the value objects to be included in the key constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current Metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="IndexHasKeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="KeyConstraintType">
        <xs:attribute name="name" type="ModelNameType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the name of the index, a reference to an index, or the name of a uniqueness constraint.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedIndexHasKeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="IndexHasKeyConstraintType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies a Metapath that can be evaluated to get the value objects to be included in the index constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current Metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedIndexConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="KeyConstraintType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the value objects to be included in the index constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current Metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ModelNameType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the name of the index, a reference to an index, or the name of a uniqueness constraint.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ExpectConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="message" type="StringDatatype" minOccurs="0"/>
          <xs:group ref="ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="test" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>A Metapath test that is expected to pass in this context.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedExpectConstraintType">
    <xs:complexContent>
      <xs:extension base="ExpectConstraintType">
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a Metaschema Metapath. If the value is "." and the containing Metaschema object is a field or flag, the constraint applies to the value of the field or flag. Otherwise, the scope value "." is not allowed to be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TargetedHasCardinalityConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:group ref="ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="target" type="MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a Metaschema Metapath. If the
              value is "." and the containing Metaschema object is a field, the constraint applies
              to the field's value. Otherwise, the scope value "." is not allowed to be
              used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min-occurs" type="NonNegativeIntegerDatatype">
          <xs:annotation>
            <xs:documentation>Minimum occurrence of assemblies or fields within the set of objects
              identified by the <code>target</code>. This value cannot be less than the
              corresponding value defined on the target.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-occurs" type="NonNegativeIntegerDatatype">
          <xs:annotation>
            <xs:documentation>Maximum occurrence of assemblies or fields within the set of objects
              identified by the <code>target</code>. This value must be less than the corresponding
              value defined on the target.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintLetType">
    <xs:sequence>
      <xs:group ref="ConstraintContentsGroup"/>
    </xs:sequence>
    <xs:attribute name="var" type="TokenDatatype" use="required"/>
    <xs:attribute name="expression" type="MetaschemaPathType" use="required"/>
  </xs:complexType>

  <xs:group name="LetExpressionGroup">
    <xs:sequence>
      <xs:element name="let" type="ConstraintLetType" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Declares a variable whose name is bound to the result of the Metapath expression. These variables can be used in target and other Metapath expressions used in constrains that are declared in the same context or in constraints declared in a child assembly, field, or flag.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="DefineFlagConstraintsType">
    <xs:sequence>
      <xs:group ref="LetExpressionGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element minOccurs="0" name="allowed-values" type="AllowedValuesType">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values for the flag.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="matches" type="MatchesConstraintType">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values based on the provided regex pattern.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="index-has-key" type="IndexHasKeyConstraintType">
          <xs:annotation>
            <xs:documentation>Checks that the specified <code>key-field</code> values match a key in the index with the specified <code>name</code>.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="expect" type="ExpectConstraintType">
          <xs:annotation>
            <xs:documentation>Checks that the specified test returns true in this evaluation context.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  
  <xs:group name="TargetedCommonConstraintsGroup">
    <xs:choice>
      <xs:element name="allowed-values" type="TargetedAllowedValuesConstraintType">
        <xs:annotation>
          <xs:documentation>Constrains the allowed values for the flag or field referenced by the scope attribute.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="matches" type="TargetedMatchesConstraintType">
        <xs:annotation>
          <xs:documentation>Constrains the allowed values based on the provided regex pattern or checks that the value conforms to the specified datatype.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="index-has-key" type="TargetedIndexHasKeyConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified <code>key-field</code> values match a key in the index with the specified <code>name</code>.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expect" type="TargetedExpectConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified test returns true in this evaluation context.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:group name="AssemblyConstraintsGroup">
    <xs:choice>
      <xs:element name="index" type="TargetedIndexConstraintType">
        <xs:annotation>
          <xs:documentation>Defines a new named index. Each entry in the index will have a unique key, based on the <code>key-field</code> elements, and an associated object value, based on the <code>target</code> selection..</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="is-unique" type="TargetedKeyConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified set of <code>target</code> entries have a key, based on the <code>key-field</code> entries that is unique. The <code>name</code> identifies the name of the uniqueness constraint, which can be used for error reporting, etc.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has-cardinality" type="TargetedHasCardinalityConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified set of <code>target</code> entries match the provided cardinality.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:complexType name="DefineFieldConstraintsType">
    <xs:sequence>
      <xs:group ref="LetExpressionGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="TargetedCommonConstraintsGroup"/>
      </xs:choice>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="DefineAssemblyConstraintsType">
    <xs:sequence>
      <xs:group ref="LetExpressionGroup"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="TargetedCommonConstraintsGroup"/>
        <xs:group ref="AssemblyConstraintsGroup"/>
      </xs:choice>
      <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <!-- *********************************** -->
  <!-- * Metaschema External Constraints * -->
  <!-- *********************************** -->
  <xs:element name="METASCHEMA-CONSTRAINTS">
    <xs:annotation>
      <xs:documentation>Root element of a Metaschema external constraints definition. Defines rules to be applied to an existing set of Metaschema models.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="name" type="StringDatatype">
          <xs:annotation>
            <xs:documentation>The name of this constraint set.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="version" type="VersionType">
          <xs:annotation>
            <xs:documentation>The version of this constraint set.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="import" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>To import a set of Metaschema constraints from an out-of-line resource, supporting composition of constraint sets.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="href" type="URIReferenceDatatype" use="required">
              <xs:annotation>
                <xs:documentation>A relative or absolute URI for retrieving an out-of-line Metaschema definition.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="namespace-binding" type="NamespaceBindingType" minOccurs="0" maxOccurs="unbounded"/> 
        <xs:element name="scope" maxOccurs="unbounded">
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:element name="assembly">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="DefineAssemblyConstraintsType">
                      <xs:attribute name="target" type="MetaschemaPathType" use="required"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="field">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="DefineFieldConstraintsType">
                      <xs:attribute name="target" type="MetaschemaPathType" use="required"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="flag">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="DefineFlagConstraintsType">
                      <xs:attribute name="target" type="MetaschemaPathType" use="required"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:attribute name="metaschema-namespace" type="URIDatatype" use="required"/>
            <xs:attribute name="metaschema-short-name" type="ShortNameType" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="remarks" type="RemarksType" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
