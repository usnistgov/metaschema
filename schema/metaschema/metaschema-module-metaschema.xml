<?xml version="1.0" encoding="UTF-8"?>
<METASCHEMA xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://csrc.nist.gov/ns/oscal/metaschema/1.0 ../xml/metaschema.xsd"
 xmlns="http://csrc.nist.gov/ns/oscal/metaschema/1.0">
    <schema-name>Metaschema Model</schema-name>
    <schema-version>1.0.0-M2</schema-version>
    <short-name>metaschema-model</short-name>
    <namespace>http://csrc.nist.gov/ns/oscal/metaschema/1.0</namespace>
    <json-base-uri>http://csrc.nist.gov/ns/oscal/metaschema/1.0</json-base-uri>
    
    <define-assembly name="METASCHEMA">
        <formal-name>Metaschema Module</formal-name>
        <description>A declaration of the Metaschema module.</description>
        <root-name>METASCHEMA</root-name>
        <define-flag name="abstract" as-type="token" default="no">
            <formal-name>Is Abstract?</formal-name>
            <description>Determines if the Metaschema module is abstract ('yes') or not ('no').</description>
            <constraint>
                <allowed-values>
                    <enum value="yes"/>
                    <enum value="no"/>
                </allowed-values>
            </constraint>
        </define-flag>
        <model>
            <define-field name="schema-name" as-type="markup-line" min-occurs="1" max-occurs="1">
                <formal-name>Module Name</formal-name>
                <description>The name of the information model represented by this Metaschema definition.</description>
            </define-field>
            <define-field name="schema-version" as-type="string" min-occurs="1" max-occurs="1">
                <description>A version string used to distinguish between multiple revisions of the same Metaschema module.</description>
            </define-field>
            <define-field name="short-name" as-type="token" min-occurs="1" max-occurs="1">
                <formal-name>Module Short Name</formal-name>
                <description>A short (code) name to be used for the Metaschema module. This name may be used as a constituent of names assigned to derived artifacts, such as schemas and conversion utilities.</description>
            </define-field>
            <define-field name="namespace" as-type="uri" min-occurs="1" max-occurs="1">
                <formal-name>Module Collection Namespace</formal-name>
                <description>The namespace for the collection of Metaschema module this Metaschema module belongs to. This value is also used as the XML namespace governing the names of elements in XML documents. By using this namespace, documents and document fragments used in mixed-format environments may be distinguished from neighbor XML formats using another namespaces. This value is not reflected in Metaschema JSON.</description>
            </define-field>
            <define-field name="json-base-uri" as-type="uri" min-occurs="1" max-occurs="1">
                <formal-name>JSON Base URI</formal-name>
                <description>The JSON Base URI is the nominal base URI assigned to a JSON Schema instance expressing the model defined by this Metaschema module.</description>
            </define-field>
            <field ref="remarks"/>
            <define-assembly name="import" max-occurs="unbounded">
                <formal-name>Module Import</formal-name>
                <description>Imports a set of Metaschema modules contained in another resource. Imports support the reuse of common information structures.</description>
                <group-as name="imports" in-json="ARRAY"/>
                <define-flag name="href" as-type="uri-reference" required="yes">
                    <formal-name>Import URI Reference</formal-name>
                    <description>A relative or absolute URI for retrieving an out-of-line Metaschema definition.</description>
                </define-flag>
            </define-assembly>
            <choice-group max-occurs="unbounded">
                <group-as name="definitions" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <define-assembly name="define-assembly">
			        <formal-name>Global Assembly Definition</formal-name>
			        <description>In XML, an element with structured element content. In JSON, an object with properties. Defined globally, an assembly can be assigned to appear in the <code>model</code> of any assembly (another assembly type, or itself), by <code>assembly</code> reference.</description>
                    <discriminator-value>assembly</discriminator-value>
			        <flag ref="definition-name" required="yes">
			            <formal-name>Global Assembly Name</formal-name>
			        </flag>
			        <flag ref="definition-index">
			            <formal-name>Global Assembly Binary Name</formal-name>
			        </flag>
			        <flag ref="definition-scope"/>
			        <flag ref="definition-deprecated"/>
			        <model>
			            <field ref="formal-name"/>
			            <field ref="description"/>
			            <assembly ref="property" max-occurs="unbounded">
			                <group-as name="props" in-json="ARRAY"/>
			            </assembly>
			            <choice>
			                <field ref="use-name"/>
			                <define-field name="root-name" as-type="token" min-occurs="1">
			                    <formal-name>Root Name</formal-name>
			                    <description>Provides a root name, for when the definition is used as the root of a node hierarchy.</description>
			                    <json-value-key>name</json-value-key>
			                    <flag ref="alt-name-index"/>
			                </define-field>
			            </choice>
			            <assembly ref="json-key"/>
			            <choice-group min-occurs="0" max-occurs="unbounded">
			                <group-as name="flags" in-json="ARRAY"/>
			                <discriminator>object-type</discriminator>
			                <assembly ref="inline-define-flag">
			                    <discriminator-value>flag</discriminator-value>
			                </assembly>
			                <assembly ref="flag-reference">
			                    <discriminator-value>flag-ref</discriminator-value>
			                </assembly>
			            </choice-group>
			            <assembly ref="assembly-model"/>
			            <assembly ref="assembly-constraints"/>
			            <field ref="remarks"/>
			            <assembly ref="example" max-occurs="unbounded">
			                <group-as name="examples" in-json="ARRAY"/>
			            </assembly>
			        </model>
			    </define-assembly>
                <define-assembly name="define-field">
                    <formal-name>Global Field Definition</formal-name>
                    <discriminator-value>field</discriminator-value>
                    <flag ref="definition-name" required="yes">
                        <formal-name>Global Field Name</formal-name>
                    </flag>
                    <flag ref="definition-index">
                        <formal-name>Global Field Binary Name</formal-name>
                    </flag>
                    <flag ref="definition-scope"/>
                    <flag ref="definition-deprecated"/>
                    <flag ref="as-type-field"/>
                    <flag ref="default-value">
                        <formal-name>Default Field Value</formal-name>
                    </flag>
                    <model>
                        <field ref="formal-name"/>
                        <field ref="description"/>
                        <assembly ref="property" max-occurs="unbounded">
                            <group-as name="props" in-json="ARRAY"/>
                        </assembly>
                        <field ref="use-name"/>
                        <assembly ref="json-key"/>
                        <choice>
                            <define-field name="json-value-key" as-type="token">
                                <formal-name>Field Value JSON Property Name</formal-name>
                            </define-field>
                            <assembly ref="json-value-key-flag"/>
                        </choice>
                        <choice-group min-occurs="0" max-occurs="unbounded">
                            <group-as name="flags" in-json="ARRAY"/>
                            <discriminator>object-type</discriminator>
                            <assembly ref="inline-define-flag">
                                <discriminator-value>flag</discriminator-value>
                            </assembly>
                            <assembly ref="flag-reference">
                                <discriminator-value>flag-ref</discriminator-value>
                            </assembly>
                        </choice-group>
                        <assembly ref="field-constraints"/>
                        <field ref="remarks"/>
                        <assembly ref="example" max-occurs="unbounded">
                            <group-as name="examples" in-json="ARRAY"/>
                        </assembly>
                    </model>
                </define-assembly>
                <define-assembly name="define-flag">
                    <formal-name>Global Flag Definition</formal-name>
                    <discriminator-value>flag</discriminator-value>
                    <flag ref="definition-name" required="yes">
                        <formal-name>Global Flag Name</formal-name>
                    </flag>
                    <flag ref="definition-index">
                        <formal-name>Global Flag Binary Name</formal-name>
                    </flag>
                    <flag ref="definition-scope"/>
                    <flag ref="definition-deprecated"/>
                    <flag ref="as-type-simple" default="string"/>
                    <flag ref="default-value">
                        <formal-name>Default Flag Value</formal-name>
                    </flag>
                    <model>
                        <field ref="formal-name"/>
                        <field ref="description"/>
                        <assembly ref="property" max-occurs="unbounded">
                            <group-as name="props" in-json="ARRAY"/>
                        </assembly>
                        <field ref="use-name"/>
                        <assembly ref="flag-constraints"/>
                        <field ref="remarks"/>
                        <assembly ref="example" max-occurs="unbounded">
                            <group-as name="examples" in-json="ARRAY"/>
                        </assembly>
                    </model>
                </define-assembly>
            </choice-group>
        </model>
        <constraint>
            <let var="keywords" expression="'ancestor', 'ancestor-or-self', 'and', 'as', 'attribute', 'cast', 'castable', 'child', 'comment', 'descendant', 'descendant-or-self', 'div', 'document-node', 'element', 'else', 'empty-sequence', 'eq', 'every', 'except', 'following', 'following-sibling', 'for', 'function', 'ge', 'gt', 'idiv', 'if', 'in', 'instance', 'intersect', 'is', 'item', 'le', 'let', 'lt', 'mod', 'namespace', 'namespace-node', 'ne', 'node', 'of', 'or', 'parent', 'preceding', 'preceding-sibling', 'processing-instruction', 'return', 'satisfies', 'schema-attribute', 'schema-element', 'self', 'some', 'text', 'then', 'to', 'treat', 'union'"/>
        </constraint>
    </define-assembly>
    
    <define-assembly name="inline-define-assembly">
        <formal-name>Inline Assembly Definition</formal-name>
        <use-name>define-assembly</use-name>
        <flag ref="definition-name" required="yes">
            <formal-name>Inline Assembly Name</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Inline Assembly Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="cardinality-min-occurs" default="0"/>
        <flag ref="cardinality-max-occurs" default="1"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="json-key"/>
            <assembly ref="group-as"/>
            <choice-group min-occurs="0" max-occurs="unbounded">
                <group-as name="flags" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="inline-define-flag">
                    <discriminator-value>flag</discriminator-value>
                </assembly>
                <assembly ref="flag-reference">
                    <discriminator-value>flag-ref</discriminator-value>
                </assembly>
            </choice-group>
            <assembly ref="assembly-model"/>
            <assembly ref="assembly-constraints"/>
            <field ref="remarks"/>
            <assembly ref="example" max-occurs="unbounded">
                <group-as name="examples" in-json="ARRAY"/>
            </assembly>
        </model>
    </define-assembly>

    <define-assembly name="inline-define-field">
        <formal-name>Inline Field Definition</formal-name>
        <use-name>define-field</use-name>
        <flag ref="definition-name" required="yes">
            <formal-name>Inline Field Name</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Inline Field Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="as-type-field"/>
        <flag ref="default-value">
            <formal-name>Default Field Value</formal-name>
        </flag>
        <flag ref="cardinality-min-occurs" default="0"/>
        <flag ref="cardinality-max-occurs" default="1"/>
        <flag ref="field-in-xml"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="json-key"/>
            <choice>
                <define-field name="json-value-key" as-type="token">
                    <formal-name>Field Value JSON Property Name</formal-name>
                </define-field>
                <assembly ref="json-value-key-flag"/>
            </choice>
            <assembly ref="group-as"/>
            <choice-group min-occurs="0" max-occurs="unbounded">
                <group-as name="flags" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="inline-define-flag">
                    <discriminator-value>flag</discriminator-value>
                </assembly>
                <assembly ref="flag-reference">
                    <discriminator-value>flag-ref</discriminator-value>
                </assembly>
            </choice-group>
            <assembly ref="field-constraints"/>
            <field ref="remarks"/>
            <assembly ref="example" max-occurs="unbounded">
                <group-as name="examples" in-json="ARRAY"/>
            </assembly>
        </model>
    </define-assembly>
    
    <define-assembly name="inline-define-flag">
        <formal-name>Inline Flag Definition</formal-name>
        <use-name>define-flag</use-name>
        <flag ref="definition-name" required="yes">
            <formal-name>Inline Flag Name</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Inline Flag Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="as-type-simple" default="string"/>
        <flag ref="default-value">
            <formal-name>Default Flag Value</formal-name>
        </flag>
        <flag ref="flag-required"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="flag-constraints"/>
            <field ref="remarks"/>
            <assembly ref="example" max-occurs="unbounded">
                <group-as name="examples" in-json="ARRAY"/>
            </assembly>
        </model>
    </define-assembly>

    <define-assembly name="any">
        <formal-name>Any Additional Content</formal-name>
        <!-- QUESTION: It's wierd this doesn't have a cardinality. The assumption is it is always max many. -->
    </define-assembly>

    <define-assembly name="assembly-reference">
        <formal-name>Assembly Reference</formal-name>
        <use-name>assembly</use-name>
        <flag ref="definition-reference" required="yes">
            <formal-name>Global Assembly Reference</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Assembly Reference Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="cardinality-min-occurs" default="0"/>
        <flag ref="cardinality-max-occurs" default="1"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="use-name"/>
            <assembly ref="group-as"/>
            <field ref="remarks"/>
        </model>
    </define-assembly>

    <define-assembly name="field-reference">
        <formal-name>Field Reference</formal-name>
        <use-name>field</use-name>
        <flag ref="definition-reference" required="yes">
            <formal-name>Global Field Reference</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Field Reference Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="default-value">
            <formal-name>Default Field Value</formal-name>
        </flag>
        <flag ref="cardinality-min-occurs" default="0"/>
        <flag ref="cardinality-max-occurs" default="1"/>
        <flag ref="field-in-xml"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="use-name"/>
            <assembly ref="group-as"/>
            <field ref="remarks"/>
        </model>
    </define-assembly>

    <define-assembly name="flag-reference">
        <formal-name>Flag Reference</formal-name>
        <use-name>flag</use-name>
        <flag ref="definition-reference" required="yes">
            <formal-name>Global Flag Reference</formal-name>
        </flag>
        <flag ref="definition-index">
            <formal-name>Flag Reference Binary Name</formal-name>
        </flag>
        <flag ref="definition-deprecated"/>
        <flag ref="default-value">
            <formal-name>Default Flag Value</formal-name>
        </flag>
        <flag ref="flag-required"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="use-name"/>
            <field ref="remarks"/>
        </model>
    </define-assembly>
    
    <define-assembly name="assembly-model">
        <use-name>model</use-name>
        <model>
            <choice-group min-occurs="0" max-occurs="unbounded">
                <group-as name="instances" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="assembly-reference">
                    <discriminator-value>assembly-ref</discriminator-value>
                </assembly>
                <assembly ref="inline-define-assembly">
                    <discriminator-value>assembly</discriminator-value>
                </assembly>
                <assembly ref="field-reference">
                    <discriminator-value>field-ref</discriminator-value>
                </assembly>
                <assembly ref="inline-define-field">
                    <discriminator-value>field</discriminator-value>
                </assembly>
                <define-assembly name="choice">
                    <formal-name>Choice</formal-name>
                    <model>
                        <choice-group min-occurs="1" max-occurs="unbounded">
                            <group-as name="choices" in-json="ARRAY"/>
                            <discriminator>object-type</discriminator>
                            <assembly ref="assembly-reference">
                                <discriminator-value>assembly-ref</discriminator-value>
                            </assembly>
                            <assembly ref="inline-define-assembly">
                                <discriminator-value>assembly</discriminator-value>
                            </assembly>
                            <assembly ref="field-reference">
                                <discriminator-value>field-ref</discriminator-value>
                            </assembly>
                            <assembly ref="inline-define-field">
                                <discriminator-value>field</discriminator-value>
                            </assembly>
                        </choice-group>
                        <assembly ref="any"/>
                    </model>
                </define-assembly>
                <define-assembly name="choice-group">
                    <formal-name>Choice Grouping</formal-name>
                    <flag ref="cardinality-min-occurs" default="0"/>
                    <!-- require a max value that is greater than 1 -->
                    <flag ref="cardinality-max-occurs" default="unbounded"/>
                    <model>
                        <assembly ref="json-key"/>
                        <assembly ref="group-as" min-occurs="1"/>
                        <define-field name="discriminator" as-type="token" default="object-type">
                            <formal-name>Discriminator JSON Property</formal-name>
                        </define-field>
                        <choice-group min-occurs="1" max-occurs="unbounded">
                            <group-as name="choices" in-json="ARRAY"/>
                            <discriminator>object-type</discriminator>
                            <define-assembly name="assembly">
                                <formal-name>Grouping Assembly Reference</formal-name>
                                <discriminator-value>assembly-ref</discriminator-value>
                                <flag ref="definition-reference" required="yes">
                                    <formal-name>Global Assembly Reference</formal-name>
                                </flag>
                                <flag ref="definition-index">
                                    <formal-name>Assembly Reference Binary Name</formal-name>
                                </flag>
                                <flag ref="definition-deprecated"/>
                                <model>
                                    <field ref="formal-name"/>
                                    <field ref="description"/>
                                    <assembly ref="property" max-occurs="unbounded">
                                        <group-as name="props" in-json="ARRAY"/>
                                    </assembly>
                                    <field ref="use-name"/>
                                    <field ref="grouped-discriminator-value"/>
                                    <field ref="remarks"/>
                                </model>
                            </define-assembly>
                            <define-assembly name="define-assembly">
                                <formal-name>Inline Assembly Definition</formal-name>
                                <discriminator-value>assembly</discriminator-value>
                                <flag ref="definition-name" required="yes">
                                    <formal-name>Inline Assembly Name</formal-name>
                                </flag>
                                <flag ref="definition-index">
                                    <formal-name>Inline Assembly Binary Name</formal-name>
                                </flag>
                                <flag ref="definition-deprecated"/>
                                <model>
                                    <field ref="formal-name"/>
                                    <field ref="description"/>
                                    <assembly ref="property" max-occurs="unbounded">
                                        <group-as name="props" in-json="ARRAY"/>
                                    </assembly>
                                    <field ref="grouped-discriminator-value"/>
                                    <choice-group min-occurs="0" max-occurs="unbounded">
                                        <group-as name="flags" in-json="ARRAY"/>
                                        <discriminator>object-type</discriminator>
                                        <assembly ref="inline-define-flag">
                                            <discriminator-value>flag</discriminator-value>
                                        </assembly>
                                        <assembly ref="flag-reference">
                                            <discriminator-value>flag-ref</discriminator-value>
                                        </assembly>
                                    </choice-group>
                                    <assembly ref="assembly-model"/>
                                    <assembly ref="assembly-constraints"/>
                                    <field ref="remarks"/>
                                    <assembly ref="example" max-occurs="unbounded">
                                        <group-as name="examples" in-json="ARRAY"/>
                                    </assembly>
                                </model>
                            </define-assembly>
                            
                            <define-assembly name="field">
                                <formal-name>Grouping Field Reference</formal-name>
                                <discriminator-value>field-ref</discriminator-value>
                                <flag ref="definition-reference" required="yes">
                                    <formal-name>Global Field Reference</formal-name>
                                </flag>
                                <flag ref="definition-index">
                                    <formal-name>Field Reference Binary Name</formal-name>
                                </flag>
                                <flag ref="definition-deprecated"/>
                                <flag ref="default-value">
                                    <formal-name>Default Field Value</formal-name>
                                </flag>
                                <flag ref="field-in-xml"/>
                                <model>
                                    <field ref="formal-name"/>
                                    <field ref="description"/>
                                    <assembly ref="property" max-occurs="unbounded">
                                        <group-as name="props" in-json="ARRAY"/>
                                    </assembly>
                                    <field ref="use-name"/>
                                    <field ref="grouped-discriminator-value"/>
                                    <field ref="remarks"/>
                                </model>
                            </define-assembly>
                            <define-assembly name="define-field">
                                <formal-name>Inline Field Definition</formal-name>
                                <discriminator-value>field</discriminator-value>
                                <flag ref="definition-name" required="yes">
                                    <formal-name>Inline Field Name</formal-name>
                                </flag>
                                <flag ref="definition-index">
                                    <formal-name>Inline Field Binary Name</formal-name>
                                </flag>
                                <flag ref="definition-deprecated"/>
                                <flag ref="as-type-field"/>
                                <flag ref="default-value">
                                    <formal-name>Default Field Value</formal-name>
                                </flag>
                                <model>
                                    <field ref="formal-name"/>
                                    <field ref="description"/>
                                    <assembly ref="property" max-occurs="unbounded">
                                        <group-as name="props" in-json="ARRAY"/>
                                    </assembly>
                                    <field ref="grouped-discriminator-value"/>
                                    <choice>
                                        <define-field name="json-value-key" as-type="token">
                                            <formal-name>Field Value JSON Property Name</formal-name>
                                        </define-field>
                                        <assembly ref="json-value-key-flag"/>
                                    </choice>
                                    <choice-group min-occurs="0" max-occurs="unbounded">
                                        <group-as name="flags" in-json="ARRAY"/>
                                        <discriminator>object-type</discriminator>
                                        <assembly ref="inline-define-flag">
                                            <discriminator-value>flag</discriminator-value>
                                        </assembly>
                                        <assembly ref="flag-reference">
                                            <discriminator-value>flag-ref</discriminator-value>
                                        </assembly>
                                    </choice-group>
                                    <assembly ref="field-constraints"/>
                                    <field ref="remarks"/>
                                    <assembly ref="example" max-occurs="unbounded">
                                        <group-as name="examples" in-json="ARRAY"/>
                                    </assembly>
                                </model>
                            </define-assembly>
                        </choice-group>
                        <field ref="remarks"/>
                    </model>
                </define-assembly>
            </choice-group>
            <assembly ref="any"/>
        </model>
    </define-assembly>

    <define-assembly name="json-value-key-flag">
        <formal-name>Flag Used as the Field Value's JSON Property Name</formal-name>
        <define-flag name="flag-ref" as-type="token" required="yes">
            <formal-name>Flag Reference</formal-name>
        </define-flag>
    </define-assembly>
    
    <define-assembly name="group-as">
        <formal-name>Group As</formal-name>
        <define-flag name="name" as-type="token" required="yes">
            <formal-name>Grouping Name</formal-name>
        </define-flag>
        <define-flag name="in-json" as-type="token" default="SINGLETON_OR_ARRAY">
            <formal-name>In JSON Grouping Syntax</formal-name>
            <constraint>
                <allowed-values>
                    <enum value="ARRAY">Always use an array.</enum>
                    <enum value="SINGLETON_OR_ARRAY">Produce a singleton for a single member or an array for multiple members.</enum>
                    <enum value="BY_KEY">For any group of one or more members, produce an object with properties for each member, using a designated flag for their property name values, which must be distinct.</enum>
                </allowed-values>
            </constraint>            
        </define-flag>
        <define-flag name="in-xml" as-type="token" default="UNGROUPED">
            <formal-name>In XML Grouping Syntax</formal-name>
            <constraint>
                <allowed-values>
                    <enum value="GROUPED">Use a wrapper element.</enum>
                    <enum value="UNGROUPED">Do not use a wrapper element.</enum>
                </allowed-values>
            </constraint>            
        </define-flag>
    </define-assembly>
    
    <define-assembly name="example">
        <formal-name>Example</formal-name>
        <define-flag name="ref" as-type="uri-reference">
            <formal-name>Example Reference</formal-name>
        </define-flag>
        <define-flag name="path">
            <!-- Not sure what this does -->
        </define-flag>
        <model>
            <define-field name="description" as-type="markup-line">
                <formal-name>Example Description</formal-name>
            </define-field>
            <field ref="remarks"/>
            <any/>
        </model>
    </define-assembly>

    <define-flag name="definition-name" as-type="token">
        <formal-name>Definition Name</formal-name>
        <use-name>name</use-name>
        <constraint>
            <expect level="WARNING" test="not(.=$keywords)">
                <message>Names cannot be non-delimiting terminal symbols in Metapath syntax.</message>
            </expect>
        </constraint>
    </define-flag>
    
    <define-flag name="definition-reference" as-type="token">
        <formal-name>Global Definition Reference</formal-name>
        <use-name>ref</use-name>
    </define-flag>
    
    <define-flag name="definition-index" as-type="positive-integer">
        <formal-name>Definition Binary Name</formal-name>
        <use-name>index</use-name>
    </define-flag>
    
    <define-flag name="definition-scope" as-type="token" default="global">
        <formal-name>Definition Scope</formal-name>
        <use-name>scope</use-name>
        <constraint>
            <allowed-values>
                <enum value="local">This definition is only available in the context of the current Metaschema module.</enum>
                <enum value="global">This definition will be made available to any Metaschema module that includes this one either directly or indirectly through a chain of imported Metaschemas.</enum>
            </allowed-values>
        </constraint>
    </define-flag>
    
    <define-flag name="definition-deprecated">
        <formal-name>Deprecated Version</formal-name>
        <use-name>deprecated</use-name>
    </define-flag>
        
    <define-flag name="as-type-field" as-type="token" default="string">
        <formal-name>Field Value Data Type</formal-name>
        <use-name>as-type</use-name>
        <constraint>
            <allowed-values allow-other="yes">
                <enum value="markup-line"/>
                <enum value="markup-multiline"/>
                <enum value="base64"/>
                <enum value="boolean"/>
                <enum value="date"/>
                <enum value="date-time"/>
                <enum value="date-time-with-timezone"/>
                <enum value="date-with-timezone"/>
                <enum value="day-time-duration"/>
                <enum value="decimal"/>
                <enum value="email-address"/>
                <enum value="hostname"/>
                <enum value="integer"/>
                <enum value="ip-v4-address"/>
                <enum value="ip-v6-address"/>
                <enum value="non-negative-integer"/>
                <enum value="positive-integer"/>
                <enum value="string"/>
                <enum value="token"/>
                <enum value="uri"/>
                <enum value="uri-reference"/>
                <enum value="uuid"/>
            </allowed-values>
        </constraint>
    </define-flag>

    <define-flag name="as-type-simple" as-type="token">
        <formal-name>Flag Value Data Type</formal-name>
        <use-name>as-type</use-name>
        <constraint>
            <allowed-values allow-other="yes">
                <enum value="base64"/>
                <enum value="boolean"/>
                <enum value="date"/>
                <enum value="date-time"/>
                <enum value="date-time-with-timezone"/>
                <enum value="date-with-timezone"/>
                <enum value="day-time-duration"/>
                <enum value="decimal"/>
                <enum value="email-address"/>
                <enum value="hostname"/>
                <enum value="integer"/>
                <enum value="ip-v4-address"/>
                <enum value="ip-v6-address"/>
                <enum value="non-negative-integer"/>
                <enum value="positive-integer"/>
                <enum value="string"/>
                <enum value="token"/>
                <enum value="uri"/>
                <enum value="uri-reference"/>
                <enum value="uuid"/>
            </allowed-values>
        </constraint>
    </define-flag>
    
    <define-flag name="default-value">
        <formal-name>Default Value</formal-name>
        <use-name>default</use-name>
    </define-flag>
    
   <define-flag name="flag-required" as-type="token" default="no">
       <formal-name>Is Flag Required?</formal-name>
       <use-name>required</use-name>
       <constraint>
           <allowed-values>
               <enum value="yes"/>
               <enum value="no"/>
           </allowed-values>
       </constraint>
   </define-flag>
    
    <define-flag name="cardinality-min-occurs" as-type="non-negative-integer">
        <formal-name>Minimum Occurrence</formal-name>
        <use-name>min-occurs</use-name>
    </define-flag>
    <define-flag name="cardinality-max-occurs" as-type="string">
        <formal-name>Maximum Occurrence</formal-name>
        <use-name>max-occurs</use-name>
        <constraint>
            <matches regex="^[1-9][0-9]*|unbounded$"></matches>
        </constraint>
    </define-flag>

    <define-flag name="field-in-xml" as-type="token" default="WRAPPED">
        <formal-name>Field In XML</formal-name>
        <use-name>in-xml</use-name>
        <constraint>
            <allowed-values>
                <enum value="WRAPPED">Block contents of a markup-multiline field will be represented with a containing (wrapper) element in the XML.</enum>
                <enum value="UNWRAPPED">Block contents of a markup-multiline will be represented in the XML with no wrapper, making the field implicit. Among sibling fields in a given model, only one of them may be designated as UNWRAPPED.</enum>
                <enum value="WITH_WRAPPER" deprecated="0.9.0">Alias for WRAPPED.</enum>
            </allowed-values>
        </constraint>
    </define-flag>
        
    <define-field name="formal-name">
        <formal-name>Formal Name</formal-name>
        <description>A formal name for the data construct, to be presented in documentation.</description>
    </define-field>
        
    <define-field name="description" as-type="markup-line">
        <formal-name>Description</formal-name>
        <description>A short description of the data construct's purpose, describing the constructs semantics.</description>
    </define-field>
    
    <define-assembly name="property">
        <formal-name>Property</formal-name>
        <use-name>prop</use-name>
        <define-flag name="name" as-type="token" required="yes">
            <formal-name>Property Name</formal-name>
        </define-flag>
        <define-flag name="namespace" as-type="uri" default="http://csrc.nist.gov/ns/oscal/metaschema/1.0">
            <formal-name>Property Namespace</formal-name>
        </define-flag>
        <define-flag name="value" as-type="token" required="yes">
            <formal-name>Property Value</formal-name>
        </define-flag>
    </define-assembly>
    
    <define-field name="use-name" as-type="token">
        <formal-name>Use Name</formal-name>
        <description>Allows the name of the definition to be overridden.</description>
        <json-value-key>name</json-value-key>
        <flag ref="alt-name-index"/>
        <constraint>
            <expect level="WARNING" target="." test="not(.=$keywords)">
                <message>Names cannot be non-delimiting terminal symbols in Metapath syntax.</message>
            </expect>
        </constraint>
    </define-field>
    
    <define-flag name="alt-name-index" as-type="non-negative-integer">
        <formal-name>Numeric Index</formal-name>
        <description>Used for binary formats instead of the textual name.</description>
        <use-name>index</use-name>
    </define-flag>

    <define-field name="grouped-discriminator-value" as-type="token">
        <formal-name>Grouping Discriminator Value</formal-name>
        <use-name>discriminator-value</use-name>
    </define-field>
    
    <define-assembly name="json-key">
        <formal-name>JSON Key</formal-name>
        <description>Used in JSON (and similar formats) to identify a flag that will be used as the property name in an object hold a collection of sibling objects. Requires that siblings must never share <code>json-key</code> values.</description>
        <define-flag name="flag-ref" as-type="token" required="yes">
            <formal-name>JSON Key Flag Reference</formal-name>
            <description>References the flag that will serve as the JSON key.</description>
        </define-flag>
    </define-assembly>
        
    <define-field name="remarks" as-type="markup-multiline">
        <formal-name>Remarks</formal-name>
        <description>Any explanatory or helpful information to be provided about the remarks parent.</description>
        <json-value-key>remark</json-value-key>
        <define-flag name="class" as-type="token" default="ALL">
            <formal-name>Remark Class</formal-name>
            <description>Mark as 'XML' for XML-only or 'JSON' for JSON-only remarks.</description>
            <constraint>
                <allowed-values extensible="none">
                    <enum value="XML">The remark applies to only XML representations.</enum>
                    <enum value="JSON">The remark applies to only JSON and YAML representations.</enum>
                    <enum value="ALL">The remark applies to all representations.</enum>
                </allowed-values>
            </constraint>
        </define-flag>
    </define-field>


    <!-- ************************** -->
    <!-- * Metaschema Constraints * -->
    <!-- ************************** -->
    <define-assembly name="assembly-constraints">
        <use-name>constraint</use-name>
        <model>
            <assembly ref="constraint-let-expression" max-occurs="unbounded">
                <group-as name="lets" in-json="ARRAY"/>
            </assembly>
            <choice-group min-occurs="1" max-occurs="unbounded">
                <group-as name="rules" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="targeted-allowed-values-constraint"/>
                <assembly ref="targeted-expect-constraint"/>
                <assembly ref="targeted-index-has-key-constraint"/>
                <assembly ref="targeted-matches-constraint"/>
                <assembly ref="targeted-is-unique-constraint"/>
                <assembly ref="targeted-index-constraint"/>
                <assembly ref="targeted-has-cardinality-constraint"/>
            </choice-group>
        </model>
    </define-assembly>
    
    <define-assembly name="field-constraints">
        <use-name>constraint</use-name>
        <model>
            <assembly ref="constraint-let-expression" max-occurs="unbounded">
                <group-as name="lets" in-json="ARRAY"/>
            </assembly>
            <choice-group min-occurs="1" max-occurs="unbounded">
                <group-as name="rules" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="targeted-allowed-values-constraint"/>
                <assembly ref="targeted-expect-constraint"/>
                <assembly ref="targeted-index-has-key-constraint"/>
                <assembly ref="targeted-matches-constraint"/>
            </choice-group>
        </model>
    </define-assembly>
    
    <define-assembly name="flag-constraints">
        <use-name>constraint</use-name>
        <model>
            <assembly ref="constraint-let-expression" max-occurs="unbounded">
                <group-as name="lets" in-json="ARRAY"/>
            </assembly>
            <choice-group min-occurs="1" max-occurs="unbounded">
                <group-as name="rules" in-json="ARRAY"/>
                <discriminator>object-type</discriminator>
                <assembly ref="flag-allowed-values"/>
                <assembly ref="flag-expect"/>
                <assembly ref="flag-index-has-key"/>
                <assembly ref="flag-matches"/>
            </choice-group>
        </model>
    </define-assembly>

    <define-assembly name="constraint-let-expression">
        <formal-name>Constraint Let Expression</formal-name>
        <use-name>let</use-name>
        <define-flag name="var" as-type="token" required="yes">
            <formal-name>Let Variable Name</formal-name>
        </define-flag>
        <define-flag name="expression" required="yes">
            <formal-name>Let Value Metapath Expression</formal-name>
        </define-flag>
        <model>
            <field ref="remarks"/>
        </model>
    </define-assembly>

    <define-assembly name="flag-allowed-values">
        <formal-name>Allowed Values Constraint</formal-name>
        <use-name>allowed-values</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-allow-other"/>
        <flag ref="constraint-extensible"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="constraint-value-enum" min-occurs="1" max-occurs="unbounded">
                <group-as name="enums" in-json="ARRAY"/>
            </field>
            <field ref="remarks"/>
        </model>
    </define-assembly>

    <define-assembly name="flag-expect">
        <formal-name>Expect Condition Constraint</formal-name>
        <use-name>expect</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-target" required="yes">
            <formal-name>Expect Test Condition</formal-name>
            <use-name>test</use-name>
        </flag>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="expect-constraint-message"/>
            <field ref="remarks"/>
        </model>
    </define-assembly>

    <define-assembly name="flag-index-has-key">
        <formal-name>Index Has Key Constraint</formal-name>
        <use-name>index-has-key</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="index-name" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="key-constraint-field" min-occurs="1" max-occurs="unbounded">
                <formal-name>Key Constraint Field</formal-name>
                <use-name>key-field</use-name>
                <group-as name="key-fields" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>        
    </define-assembly>

    <define-assembly name="flag-matches">
        <formal-name>Value Matches Constraint</formal-name>
        <use-name>matches</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-matches-regex"/>
        <flag ref="as-type-simple">
            <formal-name>Matches Data Type</formal-name>
            <use-name>datatype</use-name>
        </flag>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>
    </define-assembly>
    
    <define-flag name="constraint-identifier" as-type="token">
        <formal-name>Constraint Identifier</formal-name>
        <use-name>id</use-name>
    </define-flag>
    
    <define-flag name="constraint-severity-level" as-type="token" default="ERROR">
        <formal-name>Constraint Severity Level</formal-name>
        <use-name>level</use-name>
        <constraint>
            <allowed-values>
                <enum value="CRITICAL">A violation of the constraint represents a serious fault in the content that will prevent typical use of the content.</enum>
                <enum value="ERROR">A violation of the constraint represents a fault in the content. This may include issues around compatibility, integrity, consistency, etc.</enum>
                <enum value="WARNING">A violation of the constraint represents a potential issue with the content.</enum>
                <enum value="INFORMATIONAL">A violation of the constraint represents a point of interest.</enum>
                <enum value="DEBUG">A violation of the constraint represents a fault in the content that may warrant review by a developer when performing model or tool development.</enum>                
            </allowed-values>
        </constraint>
    </define-flag>
    
    <define-flag name="constraint-target">
        <formal-name>Constraint Target Metapath Expression</formal-name>
        <use-name>target</use-name>
    </define-flag>

    <define-assembly name="targeted-allowed-values-constraint">
        <formal-name>Allowed Values Constraint</formal-name>
        <use-name>allowed-values</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-allow-other"/>
        <flag ref="constraint-extensible"/>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="constraint-value-enum" min-occurs="1" max-occurs="unbounded">
                <group-as name="enums" in-json="ARRAY"/>
            </field>
            <field ref="remarks"/>
        </model>
    </define-assembly>
    
    <define-flag name="constraint-allow-other" as-type="token" default="no">
        <formal-name>Allow Non-Enumerated Values?</formal-name>
        <use-name>allow-other</use-name>
        <constraint>
            <allowed-values>
                <enum value="no"/>
                <enum value="yes"/>
            </allowed-values>
        </constraint>
    </define-flag>

    <define-flag name="constraint-extensible" as-type="token" default="external">
        <formal-name>Allow Extension?</formal-name>
        <description>Determines if the given enumerated values may be extended by other allowed value constraints.</description>
        <use-name>extensible</use-name>
        <constraint>
            <allowed-values>
                <enum value="model">Can be extended by constraints within the same module.</enum>
                <enum value="external">Can be extended by external constraints.</enum>
                <enum value="none">Cannot be extended.</enum>
            </allowed-values>
        </constraint>
    </define-flag>
    
    <define-field name="constraint-value-enum" as-type="markup-line">
        <formal-name>Allowed Value Enumeration</formal-name>
        <use-name>enum</use-name>
        <json-value-key>remark</json-value-key>
        <define-flag name="value" required="yes">
            <formal-name>Allowed Value Enumeration Value</formal-name>
        </define-flag>
        <define-flag name="deprecated">
            <formal-name>Allowed Value Deprecation Version</formal-name>
        </define-flag>
    </define-field>

    <define-assembly name="targeted-matches-constraint">
        <formal-name>Value Matches Constraint</formal-name>
        <use-name>matches</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-matches-regex"/>
        <flag ref="as-type-simple">
            <formal-name>Matches Data Type</formal-name>
            <use-name>datatype</use-name>
        </flag>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>
    </define-assembly>
    
    <define-flag name="constraint-matches-regex">
        <formal-name>Matches Regular Expression</formal-name>
        <use-name>regex</use-name>
    </define-flag>

    <define-assembly name="targeted-expect-constraint">
        <formal-name>Expect Condition Constraint</formal-name>
        <use-name>expect</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-target" required="yes">
            <formal-name>Expect Test Condition</formal-name>
            <use-name>test</use-name>
        </flag>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="expect-constraint-message"/>
            <field ref="remarks"/>
        </model>
    </define-assembly>
    
    <define-field name="expect-constraint-message">
        <formal-name>Expect Condition Violation Message</formal-name>
        <use-name>message</use-name>
    </define-field>

    <define-assembly name="targeted-index-has-key-constraint">
        <formal-name>Targeted Index Has Key Constraint</formal-name>
        <use-name>index-has-key</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="index-name" required="yes"/>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="key-constraint-field" min-occurs="1" max-occurs="unbounded">
                <formal-name>Key Constraint Field</formal-name>
                <use-name>key-field</use-name>
                <group-as name="key-fields" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>        
    </define-assembly>

    <define-assembly name="key-constraint-field">
        <formal-name>Key Constraint</formal-name>
        <flag ref="constraint-target" required="yes">
            <formal-name>Key Field Value Target</formal-name>
        </flag>
        <define-flag name="pattern">
            <formal-name>Key Field Value Pattern</formal-name>
        </define-flag>
        <model>
            <field ref="remarks"/>
        </model>        
    </define-assembly>

    <define-flag name="index-name" as-type="token">
        <formal-name>Index Name</formal-name>
        <use-name>name</use-name>
    </define-flag>
    
    <define-assembly name="targeted-is-unique-constraint">
        <formal-name>Targeted Unique Constraint</formal-name>
        <use-name>is-unique</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="key-constraint-field" min-occurs="1" max-occurs="unbounded">
                <formal-name>Key Constraint Field</formal-name>
                <use-name>key-field</use-name>
                <group-as name="key-fields" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>        
    </define-assembly>

    <define-assembly name="targeted-index-constraint">
        <formal-name>Targeted Index Constraint</formal-name>
        <use-name>index</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="index-name" required="yes"/>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <assembly ref="key-constraint-field" min-occurs="1" max-occurs="unbounded">
                <formal-name>Key Constraint Field</formal-name>
                <use-name>key-field</use-name>
                <group-as name="key-fields" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>        
    </define-assembly>

    <define-assembly name="targeted-has-cardinality-constraint">
        <formal-name>Targeted Cardinality Constraint</formal-name>
        <use-name>has-cardinality</use-name>
        <flag ref="constraint-identifier"/>
        <flag ref="constraint-severity-level"/>
        <flag ref="cardinality-min-occurs"/>
        <flag ref="cardinality-max-occurs"/>
        <flag ref="constraint-target" required="yes"/>
        <model>
            <field ref="formal-name"/>
            <field ref="description"/>
            <assembly ref="property" max-occurs="unbounded">
                <group-as name="props" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>        
    </define-assembly>
    
    <!-- ******************************************** -->
    <!-- * Metaschema External Constraints (legacy) * -->
    <!-- ******************************************** -->
    <define-assembly name="metaschema-module-constraints" deprecated="1.0.0-M2">
        <formal-name>External Module Constraints</formal-name>
        <description>Defines constraint rules to be applied to an existing set of Metaschema module-based models.</description>
        <root-name>METASCHEMA-CONSTRAINTS</root-name>
        <model>
            <define-field name="name" min-occurs="1">
                <description>The name of this constraint set.</description>
            </define-field>
            <define-field name="version" min-occurs="1">
                <description>The version of this constraint set. A version string used to distinguish between multiple revisions of the same resource.</description>
            </define-field>
            <define-assembly name="import" max-occurs="unbounded">
                <description>Declares a set of Metaschema constraints from an out-of-line resource to import, supporting composition of constraint sets.</description>
                <group-as name="imports" in-json="ARRAY"/>
                <define-flag name="href" as-type="uri-reference" required="yes">
                    <description>A relative or absolute URI for retrieving an out-of-line Metaschema constraint definition.</description>
                </define-flag>
            </define-assembly>
            <define-assembly name="scope" min-occurs="1" max-occurs="unbounded">
                <group-as name="scopes" in-json="ARRAY"/>
                <define-flag name="metaschema-namespace" as-type="uri" required="yes"/>
                <define-flag name="metaschema-short-name" as-type="token" required="yes"/>
                <model>
                    <choice-group min-occurs="1">
                        <group-as name="constraints" in-json="ARRAY"/>
                        <define-assembly name="assembly">
                            <flag ref="constraint-target" required="yes"/>
                            <model>
                                <choice-group min-occurs="1" max-occurs="unbounded">
                                    <group-as name="rules" in-json="ARRAY"/>
                                    <discriminator>object-type</discriminator>
                                    <assembly ref="targeted-allowed-values-constraint"/>
                                    <assembly ref="targeted-expect-constraint"/>
                                    <assembly ref="targeted-index-has-key-constraint"/>
                                    <assembly ref="targeted-matches-constraint"/>
                                    <assembly ref="targeted-is-unique-constraint"/>
                                    <assembly ref="targeted-index-constraint"/>
                                    <assembly ref="targeted-has-cardinality-constraint"/>
                                </choice-group>
                            </model>
                        </define-assembly>
                        <define-assembly name="field">
                            <flag ref="constraint-target" required="yes"/>
                            <model>
                                <choice-group min-occurs="1" max-occurs="unbounded">
                                    <group-as name="rules" in-json="ARRAY"/>
                                    <discriminator>object-type</discriminator>
                                    <assembly ref="targeted-allowed-values-constraint"/>
                                    <assembly ref="targeted-expect-constraint"/>
                                    <assembly ref="targeted-index-has-key-constraint"/>
                                    <assembly ref="targeted-matches-constraint"/>
                                </choice-group>
                            </model>
                        </define-assembly>
                        <define-assembly name="flag">
                            <flag ref="constraint-target" required="yes"/>
                            <model>
                                <choice-group min-occurs="1" max-occurs="unbounded">
                                    <group-as name="rules" in-json="ARRAY"/>
                                    <discriminator>object-type</discriminator>
                                    <assembly ref="flag-allowed-values"/>
                                    <assembly ref="flag-expect"/>
                                    <assembly ref="flag-index-has-key"/>
                                    <assembly ref="flag-matches"/>
                                </choice-group>
                            </model>
                        </define-assembly>
                    </choice-group>
                    <field ref="remarks"/>
                </model>
            </define-assembly>
        </model>
    </define-assembly>

    <!-- ***************************************** -->
    <!-- * Metaschema External Constraints (new) * -->
    <!-- ***************************************** -->
    <define-assembly name="metaschema-meta-constraints">
        <formal-name>External Module Constraints</formal-name>
        <description>Defines constraint rules to be applied to an existing set of Metaschema module-based models.</description>
        <root-name>metaschema-meta-constraints</root-name>
        <model>
            <define-assembly name="definition-context">
                <define-flag name="name" as-type="token" required="yes"/>
                <define-flag name="namespace" as-type="uri" required="yes"/>
                <model>
                    <assembly ref="assembly-constraints" min-occurs="1">
                        <use-name>constraints</use-name>
                    </assembly>
                    <field ref="remarks"/>
                </model>
            </define-assembly>
            <assembly ref="metapath-context" min-occurs="1" max-occurs="unbounded">
		    	<use-name>context</use-name>
                <group-as name="contexts" in-json="ARRAY"/>
            </assembly>
        </model>            
    </define-assembly>

   <define-assembly name="metaschema-metapath">
      <description>A Metapath expression identifying the model node that the constraints will be applied to.</description>
      <use-name>metapath</use-name>
      <define-flag name="target" required="yes"/>
   </define-assembly>

    <define-assembly name="metapath-context">
        <model>
            <assembly ref="metaschema-metapath" min-occurs="1" max-occurs="unbounded">
                <description>A Metapath expression identifying the model node that the constraints will be applied to.</description>
                <group-as name="metapaths" in-json="ARRAY"/>
            </assembly>
            <assembly ref="assembly-constraints">
                <use-name>constraints</use-name>
            </assembly>
            <assembly ref="metapath-context" max-occurs="unbounded">
            	<use-name>context</use-name>
                <group-as name="contexts" in-json="ARRAY"/>
            </assembly>
            <field ref="remarks"/>
        </model>
    </define-assembly>
</METASCHEMA>