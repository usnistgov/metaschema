<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
  xmlns:oscal="http://csrc.nist.gov/ns/oscal/1.0"
  xmlns:m="http://csrc.nist.gov/ns/oscal/metaschema/1.0"
  targetNamespace="http://csrc.nist.gov/ns/oscal/metaschema/1.0">

  <!-- Import any OSCAL schemas needed for samples... -->
  <!--<xs:import namespace="http://csrc.nist.gov/ns/oscal/1.0"
    schemaLocation="../../../schema/xml/oscal-catalog-schema.xsd"/>-->
  <xs:element name="METASCHEMA">
    <xs:annotation>
      <xs:documentation>Root element of an OSCAL Metaschema metaschema. Defines a family of data
        structures.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="m:schema-name"/>
        <xs:element ref="m:schema-version"/>
        <xs:element ref="m:short-name"/>
        <xs:element ref="m:namespace"/>
        <xs:element ref="m:json-base-uri"/>
        <xs:element ref="m:remarks" minOccurs="0"/>
        <xs:choice maxOccurs="unbounded">
          <xs:element ref="m:import"/>
          <xs:element name="define-assembly" type="m:GlobalAssemblyDefinitionType"/>
          <xs:element name="define-field" type="m:GlobalFieldDefinitionType"/>
          <xs:element name="define-flag" type="m:GlobalFlagDefinitionType"/>
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="abstract">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="yes"/>
            <xs:enumeration value="no"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:anyAttribute processContents="lax"/>
    </xs:complexType>
    <xs:unique name="unique-constraint-ids">
      <xs:selector xpath=".//m:allowed-values|.//m:matches|.//m:index-has-key|.//m:is-unique|.//m:has-cardinality|.//m:expect|.//m:index"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:key name="key-index-constraint">
      <xs:selector xpath=".//m:index"/>
      <xs:field xpath="@name"/>
    </xs:key>
<!--    <xs:keyref name="keyref-index-has-key" refer="m:key-index-constraint">
      <xs:selector xpath=".//m:index-has-key"/>
      <xs:field xpath="@name"/>
    </xs:keyref>
-->  </xs:element>

  <xs:complexType name="GlobalAssemblyDefinitionType">
    <xs:annotation>
      <xs:documentation>An element with structured element content in XML; in JSON, an object with
        properties. Defined globally, an assembly can be assigned to appear in the <code>model</code> of any assembly (another assembly type, or itself), by <code>assembly</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:choice>
        <xs:element minOccurs="0" name="root-name" type="xs:NCName"/>
        <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
      </xs:choice>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-key"/>
      <xs:choice  minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="m:flag"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="define-flag"
          type="m:LocalFlagDefinitionType"/>
      </xs:choice>
      <xs:element name="model" minOccurs="0" type="m:AssemblyModelType"/>
      <xs:element minOccurs="0" name="constraint" type="m:DefineAssemblyConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <xs:attribute name="scope" type="m:ScopeType" default="global"/>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>

  <xs:complexType name="AssemblyModelType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="m:assembly"/>
        <xs:element ref="m:field"/>
        <xs:element name="define-assembly" type="m:LocalAssemblyDefinitionType"/>
        <xs:element name="define-field" type="m:LocalFieldDefinitionType"/>
        <xs:element ref="m:choice"/>
      </xs:choice>
      <xs:element ref="m:any" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GlobalFieldDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or mixed
        content. Defined globally, a field can be assigned to appear in the <code>model</code> of any assembly by <code>field</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-key"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-value-key"/>
      <xs:choice  minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="m:flag"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="define-flag"
          type="m:LocalFlagDefinitionType"/>
      </xs:choice>
      <xs:element minOccurs="0" name="constraint" type="m:DefineFieldConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attribute name="as-type" type="m:FieldDatatypesType" default="string"/>
    <xs:attribute name="collapsible" type="m:BooleanType" default="no"/>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <xs:attribute name="scope" type="m:ScopeType" default="global"/>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>


  <xs:complexType name="GlobalFlagDefinitionType">
    <xs:annotation>
      <xs:documentation>A data point to be expressed as an attribute in the XML or a name/value pair
        in the JSON. A flag may also be defined implicitly with the assembly or field to which it
        applies. Defined globally, a flag can be assigned to any field or assembly by <code>flag</code> reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
      <xs:element name="constraint" minOccurs="0" type="m:DefineFlagConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <!-- datatype should default to 'string' -->
    <xs:attribute name="as-type" type="m:SimpleDatatypesType" default="string"/>
    <xs:attribute name="scope" type="m:ScopeType" default="global"/>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>

  <xs:complexType name="LocalAssemblyDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or mixed
        content. A local definition describes and constrains the appearance of the field only in this (assembly) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-key"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-value-key"/>
      <xs:element minOccurs="0" ref="m:group-as"/>
      <xs:choice  minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="m:flag"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="define-flag"
          type="m:LocalFlagDefinitionType"/>
      </xs:choice>
      <xs:element name="model" minOccurs="0" type="m:AssemblyModelType"/>
      <xs:element minOccurs="0" name="constraint" type="m:DefineAssemblyConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attributeGroup ref="m:CardinalitySpecificationGroup"/>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>


  <xs:complexType name="LocalFieldDefinitionType">
    <xs:annotation>
      <xs:documentation>In JSON, an object with a nominal string value (potentially with internal
        inline - not fully structured - markup). In XML, an element with string or mixed
        content. A local definition describes and constrains the appearance of the field only in this (assembly) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-key"/>
      <xs:element minOccurs="0" maxOccurs="1" ref="m:json-value-key"/>
      <xs:element minOccurs="0" ref="m:group-as"/>
      <xs:choice  minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="m:flag"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="define-flag"
          type="m:LocalFlagDefinitionType"/>
      </xs:choice>
      <xs:element minOccurs="0" name="constraint" type="m:DefineFieldConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attribute name="as-type" type="m:FieldDatatypesType" default="string"/>
    <xs:attribute name="collapsible" type="m:BooleanType" default="no"/>
    <xs:attributeGroup ref="m:CardinalitySpecificationGroup"/>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <xs:attribute name="in-xml" type="m:InXmlWrappedType" default="WITH_WRAPPER">
      <xs:annotation>
        <xs:documentation>A field with assigned datatype 'markup-multiline' may be designated for representation with or without a containing (wrapper) element
          in XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>

  <xs:complexType name="LocalFlagDefinitionType">
    <xs:annotation>
      <xs:documentation>A data point to be expressed as an attribute in the XML or a name/value pair in the JSON. A local definition describes and constrains the appearance of the flag only in its parent (assembly or field) context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:formal-name"/>
      <xs:element minOccurs="0" ref="m:description"/>
      <xs:element name="constraint" minOccurs="0" type="m:DefineFlagConstraintsType"/>
      <xs:element minOccurs="0" ref="m:remarks"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:example"/>
    </xs:sequence>
    <xs:attribute name="name" use="required" type="xs:NCName"/>
    <!-- datatype should default to 'string' -->
    <xs:attribute name="as-type" type="m:SimpleDatatypesType" default="string"/>
    <xs:attribute name="required" type="m:BooleanType" default="no"/>
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>

  <xs:element name="formal-name" type="xs:string">
    <xs:annotation>
      <xs:documentation>A formal name for the data construct, to be presented in documentation. It
        is permissible for a formal name to provide nothing but an expanson of what is already given
        by a tag (for example, this element could have formal name "Formal name") but it should at
        the very least confirm the intended semantics for the user, not confuse them.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="namespace" type="xs:anyURI">
    <xs:annotation>
      <xs:documentation>The XML namespace governing the names of elements in XML documents, which
        expect to be conformant to the schemas expressed by this metaschema. By using this
        namespace, documents and document fragments used in mixed-format environments may be
        distinguished from neighbor XML formats using other namespaces. NB this is only for the
        convenience of XML users; this value is not reflected in OSCAL JSON, and OSCAL applications
        should not rely on namespaces alone to disambiguate or resolve semantics.</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="json-base-uri" type="xs:anyURI">
    <xs:annotation>
      <xs:documentation>The JSON Base URI is nominal base URI assigned to a JSON Schema instance expressing the model defined by this metaschema.</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:group name="MarkupElementsGroup">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:a"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:code"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:q"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:em"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:strong"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="MarkupLineType" mixed="true">
    <xs:group ref="m:MarkupElementsGroup"/>
  </xs:complexType>

  <xs:element name="description" type="m:MarkupLineType">
    <xs:annotation>
      <xs:documentation>A short description of the data construct, to be inserted into
        documentation. Unlike 'formal-name' this should not simply repeat what is readily
        discernible from a tag (element name or JSON label), but say a little more about
        it.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="remarks">
    <xs:annotation>
      <xs:documentation>Any explanatory or helpful information to be provided in the
      documentation of an assembly, field or flag.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="m:MarkupMultilineType">
          <xs:attribute name="class" type="xs:NMTOKENS">
            <xs:annotation>
              <xs:documentation>Mark as 'XML' for XML-only or 'JSON' for JSON-only remarks.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="MarkupMultilineType">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="m:p"/>
    </xs:sequence>
  </xs:complexType>    

  <xs:element name="schema-name">
    <xs:annotation>
      <xs:documentation>The name of the information model to be represented by derived schemas.</xs:documentation>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:choice maxOccurs="unbounded">
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:code"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="m:q"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>

  <xs:element name="schema-version">
    <xs:annotation>
      <xs:documentation>The version of the information model to be represented by derived schemas.</xs:documentation>
    </xs:annotation>
    <xs:complexType mixed="true"/>
  </xs:element>

  <xs:element name="short-name" type="xs:NCName">
    <xs:annotation>
      <xs:documentation>A short (code) name to be used for the metaschema, for example as a constituent of names assigned to
        derived artifacts such as schemas and conversion utilities.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="import">
    <xs:annotation>
      <xs:documentation>To import a set of declarations from an out-of-line schema, supporting reuse of common information structures.</xs:documentation>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="href" type="xs:anyURI" use="required">
        <xs:annotation>
          <xs:documentation>A relative or absolute URI for retrieving an out-of-line metaschema module.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="assembly">
    <xs:annotation>
      <xs:documentation>Referencing an assembly definition to include an assembly or assemblies of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
        <xs:element minOccurs="0" ref="m:group-as"/>
        <xs:element minOccurs="0" ref="m:remarks"/>
      </xs:sequence>
      <xs:attribute name="ref" use="required" type="xs:NCName"/>
      <xs:attributeGroup ref="m:CardinalitySpecificationGroup"/>
      <xs:anyAttribute processContents="lax"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="field">
    <xs:annotation>
      <xs:documentation>Referencing a field definition to include a field or fields of a given type in a model.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" name="use-name" type="xs:NCName"/>
        <xs:element minOccurs="0" ref="m:group-as"/>
        <xs:element minOccurs="0" ref="m:remarks"/>
      </xs:sequence>
      <xs:attribute name="ref" use="required" type="xs:NCName"/>
      <xs:attributeGroup ref="m:CardinalitySpecificationGroup"/>
      <xs:attribute name="in-xml" type="m:InXmlWrappedType" default="WITH_WRAPPER">
        <xs:annotation>
          <xs:documentation>A field with assigned datatype 'markup-multiline' may be designated for representation with or without a containing (wrapper) element
            in XML.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:anyAttribute processContents="lax"/>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name="InXmlWrappedType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="WITH_WRAPPER">
        <xs:annotation>
          <xs:documentation>Any paragraph or block contents of a markup-multiline field will be represented with a containing (wrapper) element in the XML.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNWRAPPED">
        <xs:annotation>
          <xs:documentation>With in-xml='UNWRAPPED', a field contents will be represented in the XML with no wrapper, so the field will be implicit. Among sibling fields in a given model, only one of them may be designated as UNWRAPPED.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:attributeGroup name="CardinalitySpecificationGroup">
    <xs:attribute name="min-occurs" type="xs:nonNegativeInteger" default="0">
      <xs:annotation>
        <xs:documentation>Minimum occurrence of assemblies or fields within a valid model. The default value is 0, for an optional occurrence.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-occurs" type="m:NaturalNumberOrUnboundedType" default="1">
      <xs:annotation>
        <xs:documentation>Maximum occurrence of assemblies or fields within a valid model. The default value is 1, for a single occurrence. 'unbounded' permits any number of assemblies of the designated type.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:simpleType name="NaturalNumberOrUnboundedType">
    <xs:union memberTypes="xs:positiveInteger">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="unbounded"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:complexType abstract="true" name="ConstraintType">
    <xs:sequence>
      <xs:element ref="m:formal-name" minOccurs="0"/>
      <xs:element ref="m:description" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:NCName" use="optional"/>
    <xs:attribute name="level" type="m:LevelType" default="ERROR"/>
  </xs:complexType>

  <xs:group name="ConstraintContentsGroup">
    <xs:sequence>
      <xs:element name="message" type="xs:string" minOccurs="0"/>
      <xs:element ref="m:remarks" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:simpleType name="LevelType">
    <xs:restriction base="xs:token">
      <xs:enumeration value="CRITICAL">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a serious fault in the content
            that will prevent typical use of the content.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ERROR">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a fault in the content. This
            may include issues around compatibility, integrity, consistency, etc.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARNING">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a potential issue
            with the content.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="INFORMATIONAL">
        <xs:annotation>
          <xs:documentation>A violation of the constraint represents a point of
            interest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="AllowedValuesType">
    <xs:annotation>
      <xs:documentation>Indicates a set of values to be recognized for a flag or field, with semantics asserted by a metaschema enumeration (enum).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="m:ConstraintType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" ref="m:enum"/>
          <xs:group ref="m:ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="allow-other" type="m:BooleanType" default="no">
          <xs:annotation>
            <xs:documentation>The given enumerated value or values are inclusive of other values ('yes') or not ('no', the default)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="enum">
    <xs:annotation>
      <xs:documentation>An enumerated value for a flag or field. The value is indicated by the 'value' attribute while the element contents describe the intended semantics for documentation.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="m:MarkupLineType">
          <xs:attribute name="value" use="required" type="xs:string">
            <xs:annotation>
              <xs:documentation>A value recognized for a flag or field.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="p" type="m:MarkupLineType">
    <xs:annotation>
      <xs:documentation>A paragraph or paragraph fragment, in documentation.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="a">
    <xs:complexType mixed="true">
      <xs:attribute name="href"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="q" type="xs:string"/>
  <xs:element name="code" type="xs:string"/>
  <xs:element name="em" type="xs:string"/>
  <xs:element name="strong" type="xs:string"/>

  <xs:element name="flag">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="use-name" minOccurs="0" type="xs:NCName"/>
        <xs:element minOccurs="0" ref="m:remarks"/>
      </xs:sequence>
      <xs:attribute name="ref" use="required" type="xs:NCName"/>
      <xs:attribute name="required" type="m:BooleanType" default="no"/>
      <xs:anyAttribute processContents="lax"/>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name="RegexType">
    <xs:annotation>
      <xs:documentation>A regex subset that is conformant to both https://www.w3.org/TR/xmlschema11-2/#regexes and https://www.ecma-international.org/ecma-262/11.0/index.html#sec-patterns.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="MetaschemaPathType">
    <xs:restriction base="xs:string">
      <xs:whiteSpace value="collapse"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="MatchesConstraintType">
    <!-- TODO: need a metaschema check to make sure either a pattern or a datatype is used; or make these element children and use a choice -->
    <xs:complexContent>
      <xs:extension base="m:ConstraintType">
        <xs:sequence>
          <xs:group ref="m:ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="regex" type="m:RegexType"/>
        <xs:attribute name="datatype" type="m:SimpleDatatypesType">
          <xs:annotation>
            <xs:documentation>Specifies the datatype for which the value identified by the scope
              attribute must conform to.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ScopedMatchesConstraintType">
    <xs:complexContent>
      <xs:extension base="m:MatchesConstraintType">
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a metaschema path. If the value is "." and the containing metaschema object is a field, the constraint applies to the field's value. Otherwise, the scope value "." is not allowed to be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ScopedAllowedValuesType">
    <xs:complexContent>
      <xs:extension base="m:AllowedValuesType">
        <!-- Not supporting @extends until semantics of application (scope) can be defined - which
                   constraints (global and local) are extended? 
                <xs:attribute name="extends" type="m:boolean" default="yes">
                <xs:annotation>
                  <xs:documentation>If <code>yes</code>, indicates that the provided enumerated
                    values are appended to those defined by the referenced flag. If
                    <code>no</code>, then the provided enumerated values are used in place of
                    those defined by the referenced flag/</xs:documentation>
                </xs:annotation>
              </xs:attribute>-->
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a metaschema path. If the value is "." and the containing metaschema object is a field, the constraint applies to the field's value.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="DefineFlagConstraintsType">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element minOccurs="0" name="allowed-values" type="m:AllowedValuesType">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values for the flag.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="matches" type="m:MatchesConstraintType">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values based on the provided regex pattern.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="index-has-key" type="m:IndexHasKeyConstraintType">
          <xs:annotation>
            <xs:documentation>Checks that the specified <code>key-field</code> values match a key in the index with the specified <code>name</code>.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="expect" type="m:ExpectConstraintType">
          <xs:annotation>
            <xs:documentation>Checks that the specified test returns true in this evaluation context.</xs:documentation>
          </xs:annotation>
        </xs:element>
        
      </xs:choice>
      <xs:element minOccurs="0" ref="m:remarks"/>
    </xs:sequence>
  </xs:complexType>

  <!--<xs:complexType name="flag-reference-constraints-type">
    <xs:sequence>
      <xs:choice>
        <xs:element name="allowed-values" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values for the flag.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="m:allowed-values-type">
                <xs:attribute name="extends" type="m:boolean" default="yes">
                  <xs:annotation>
                    <xs:documentation>If <code>yes</code>, indicates that the provided enumerated
                      values are appended to those defined by the referenced flag. If
                        <code>no</code>, then the provided enumerated values are used in place of
                      those defined by the referenced flag/</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType>
        </xs:element>
        <xs:element name="matches" type="m:matches-constraint-type">
          <xs:annotation>
            <xs:documentation>Constrains the allowed values based on the provided regex pattern.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:element minOccurs="0" ref="m:remarks"/>
    </xs:sequence>
  </xs:complexType>-->

  <xs:complexType name="IndexFieldType">
    <xs:sequence>
      <xs:element minOccurs="0" ref="m:remarks"/>
    </xs:sequence>
    <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
      <xs:annotation>
        <xs:documentation>Specifies the field or flag value that is used to generate the key for a given object that is a member of this index. If more than one key-field is provided, then the key is a composition of the specified key-fields. The ordering of the key-field defined the relative order of the index's key. The field or flag values pointed to must be a field value or a required flag value.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="KeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an unique key constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="m:ConstraintType">
        <xs:sequence>
          <xs:element name="key-field" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation>Specifies a value, relative to the provided <code>target</code>,
                that is to be used as part of the key. More than one key-field can be used to create
                a composite key.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:complexContent>
                <xs:extension base="m:IndexFieldType">
                  <xs:attribute name="pattern" type="m:RegexType">
                    <xs:annotation>
                      <xs:documentation>The first captured group in the regular expression is used
                        as the key value for lookup. The regular expression must not match a
                        zero-length string.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:extension>
              </xs:complexContent>
            </xs:complexType>
          </xs:element>
          <xs:group ref="m:ConstraintContentsGroup"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ScopedKeyConstraintType">
    <xs:complexContent>
      <xs:extension base="m:KeyConstraintType">
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the value objects to be included in the key constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>



  <xs:complexType name="IndexHasKeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="m:KeyConstraintType">
        <xs:attribute name="name" type="xs:NCName" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the name of the index, a reference to an index, or the name of a uniqueness constraint.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ScopedIndexHasKeyConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="m:IndexHasKeyConstraintType">
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the value objects to be included in the index constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>


  <xs:complexType name="ScopedIndexConstraintType">
    <xs:annotation>
      <xs:documentation>Defines an index, a check against an index, or a uniqueness constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="m:KeyConstraintType">
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the value objects to be included in the index constraint, or the object that contains a reference to an item in an index. If the value is ".", then the key is targeting the current metaschema object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="xs:NCName" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the name of the index, a reference to an index, or the name of a uniqueness constraint.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ExpectConstraintType">
    <xs:complexContent>
      <xs:extension base="m:ConstraintType">
        <xs:sequence>
          <xs:group ref="m:ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="test" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>A test that is expected to pass in this context. Presently, datatyping
              is not directly supported except by explicit use of data type casting functions, e.g.
              xs:double() and xs:date().</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ScopedExpectConstraintType">
    <xs:complexContent>
      <xs:extension base="m:ExpectConstraintType">
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a metaschema path. If the value is "." and the containing metaschema object is a field or flag, the constraint applies to the value of the field or flag. Otherwise, the scope value "." is not allowed to be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
    
  <xs:group name="CommonModelConstraintsGroup">
    <xs:choice>
      <xs:element name="allowed-values" type="m:ScopedAllowedValuesType">
        <xs:annotation>
          <xs:documentation>Constrains the allowed values for the flag or field referenced by the scope attribute.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="matches" type="m:ScopedMatchesConstraintType">
        <xs:annotation>
          <xs:documentation>Constrains the allowed values based on the provided regex pattern or checks that the value is conformant to the specified datatype.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="index-has-key" type="m:ScopedIndexHasKeyConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified <code>key-field</code> values match a key in the index with the specified <code>name</code>.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expect" type="m:ScopedExpectConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified test returns true in this evaluation context.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:complexType name="HasCardinalityConstraintType">
    <xs:complexContent>
      <xs:extension base="m:ConstraintType">
        <xs:sequence>
          <xs:group ref="m:ConstraintContentsGroup"/>
        </xs:sequence>
        <xs:attribute name="target" type="m:MetaschemaPathType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the target of the constraint as a metaschema path. If the
              value is "." and the containing metaschema object is a field, the constraint applies
              to the field's value. Otherwise, the scope value "." is not allowed to be
              used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min-occurs" type="xs:nonNegativeInteger">
          <xs:annotation>
            <xs:documentation>Minimum occurrence of assemblies or fields within the set of objects
              identified by the <code>target</code>. This value cannot be less than the
              corresponding value defined on the target.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-occurs" type="xs:nonNegativeInteger">
          <xs:annotation>
            <xs:documentation>Maximum occurrence of assemblies or fields within the set of objects
              identified by the <code>target</code>. This value must be less than the corresponding
              value defined on the target.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:group name="AssemblyConstraintsGroup">
    <xs:choice>
      <xs:element name="index" type="m:ScopedIndexConstraintType">
        <xs:annotation>
          <xs:documentation>Defines a new named index. Each entry in the index will have a unique key, based on the <code>key-field</code> elements, and an associated object value, based on the <code>target</code> selection..</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="is-unique" type="m:ScopedKeyConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified set of <code>target</code> entries have a key, based on the <code>key-field</code> entries that is unique. The <code>name</code> identifies the name of the uniqueness constraint, which can be used for error reporting, etc.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has-cardinality" type="m:HasCardinalityConstraintType">
        <xs:annotation>
          <xs:documentation>Checks that the specified set of <code>target</code> entries match the provided cardinality.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:complexType name="DefineFieldConstraintsType">
    <xs:sequence>
      <xs:choice minOccurs="1" maxOccurs="unbounded">
        <xs:group ref="m:CommonModelConstraintsGroup"/>
      </xs:choice>
      <xs:element minOccurs="0" ref="m:remarks"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="DefineAssemblyConstraintsType">
    <xs:sequence>
      <xs:choice minOccurs="1" maxOccurs="unbounded">
        <xs:group ref="m:CommonModelConstraintsGroup"/>
        <xs:group ref="m:AssemblyConstraintsGroup"/>
      </xs:choice>
      <xs:element ref="m:remarks" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  
  <xs:element name="choice">
    <xs:annotation>
      <xs:documentation>Within a model, indicates that only one of a set of fields or assemblies, referenced in the choice, may occur in valid instances.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="m:assembly"/>
        <xs:element ref="m:field"/>
        <xs:element name="define-assembly" type="m:LocalAssemblyDefinitionType"/>
        <xs:element name="define-field" type="m:LocalFieldDefinitionType"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>

  <xs:element name="any">
    <xs:annotation>
      <xs:documentation>Within a model, a foreign element may be permitted here..</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="example">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="m:description"/>
        <xs:element minOccurs="0" ref="m:remarks"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:any namespace="##other" processContents="lax"/>
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="href" type="xs:anyURI"/>
      <xs:attribute name="path" type="xs:string"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="json-key">
    <xs:annotation>
      <xs:documentation>In the XML, produces an attribute with the given name, whose value is used as a key value (aka object property name) in the JSON, enabling objects to be 'lifted' out of arrays when such values are distinct. Implies that siblings will never share values. Overloading with datatype 'ID' and naming the key 'id' is legitimate and useful. Even without ID validation, uniqueness of these values among siblings is validable.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="flag-name" type="xs:NCName"/>
      <!-- do not have to flag if required; it always will be <xs:attribute name="required" type="xs:NCName"/>-->
    </xs:complexType>
  </xs:element>

  <xs:element name="group-as">
    <xs:annotation>
      <xs:documentation>When a given referenced field or assembly must be wrapped in an outer grouping, these settings apply, including a name for the group, and how to express the grouping in the respective formats. Not necessary when a field or assembly has max-occurs='1'</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="name" type="xs:NCName" use="required"/>
      <xs:attribute name="in-json" type="m:JsonGroupAsBehaviorType" use="optional"
        default="SINGLETON_OR_ARRAY">
        <!-- TODO: change the default to "ARRAY" -->
        <xs:annotation>
          <xs:documentation>How to represent a grouping in JSON</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="in-xml" type="m:XmlGroupAsBehaviorType" use="optional" default="UNGROUPED">
        <xs:annotation>
          <xs:documentation>Whether to represent a grouping explicitly in XML</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name="JsonGroupAsBehaviorType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ARRAY">
        <xs:annotation>
          <xs:documentation>Always use an array</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SINGLETON_OR_ARRAY">
        <xs:annotation>
          <xs:documentation>Produce a singleton for a single member (field or assembly) or an array for multiple members</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BY_KEY">
        <xs:annotation>
          <xs:documentation>For any group (one or more members) produce an object with properties for each member, using a designated flag for their key (label) values, which must be distinct</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="XmlGroupAsBehaviorType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="GROUPED">
        <xs:annotation>
          <xs:documentation>Use a wrapper element</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNGROUPED">
        <xs:annotation>
          <xs:documentation>Do not use a wrapper element</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- a value-key provides a literal to be used in JSON as a key for the field value;
     when given as a child of a flag (reference), designates that flag's value to serve as
     the key (JSON property label) for the field's value. Inside flag this element
     must be empty.  -->
  <xs:element name="json-value-key">
    <xs:annotation>
      <xs:documentation>Used inside a field definition, designates
        a flag to be used as a label (key) to be used for the field value in the JSON on
        the field being defined. When a flag-name is provided, indicates that the value of the field
        is to be labeled in the JSON with the value of the flag.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:NCName">
          <xs:attribute name="flag-name" type="xs:NCName"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name="SimpleDatatypesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="string">
        <xs:annotation>
          <xs:documentation>A string with no leading or trailing whitespace.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="decimal"/>
      <!-- Not supporting float or double -->
      <!--<xs:enumeration value="float" />
      <xs:enumeration value="double" />-->
      <xs:enumeration value="integer"/>
      <xs:enumeration value="nonNegativeInteger"/>
      <xs:enumeration value="positiveInteger"/>
      <xs:enumeration value="dateTime"/>
      <xs:enumeration value="date"/>
      <xs:enumeration value="base64Binary"/>

      <!-- specialized datatypes -->
      <xs:enumeration value="dateTime-with-timezone"/>
      <xs:enumeration value="date-with-timezone"/>
      <!--<xs:enumeration value="percent"/>-->
      <xs:enumeration value="email"/>
      <xs:enumeration value="hostname"/>
      <xs:enumeration value="ip-v4-address"/>
      <xs:enumeration value="ip-v6-address"/>
      <xs:enumeration value="token"/>
      <xs:enumeration value="uri"/>
      <xs:enumeration value="uri-reference"/>
      <xs:enumeration value="uuid"/>
      
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="FieldDatatypesType">
    <xs:union memberTypes="m:SimpleDatatypesType">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <!--<xs:enumeration value="empty"/>-->
          <xs:enumeration value="markup-line"/>
          <xs:enumeration value="markup-multiline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <!-- TODO: check if both forms are handled. In some cases only 'yes' is handled, and 'true' is not. -->
  <xs:simpleType name="BooleanType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="yes"/>
      <xs:enumeration value="no"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ScopeType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="local">
        <xs:annotation>
          <xs:documentation>This definition is only available in the context of the current metaschema.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="global">
        <xs:annotation>
          <xs:documentation>This definition will be made available to any metaschema that includes this one either directly or indirectly through a chain of imported metaschemas.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
