<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Tue Apr 7, 2020 17:31 (UTC-04) by REx v5.49 which is Copyright (c) 1979-2019 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: xpath20h.ebnf -backtrack -xslt -tree -name xpath20h -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="xpath20h">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="11"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    50, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 4, 16, 17, 18, 19, 20, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
    21, 21, 23, 4, 24, 4, 21, 4, 25, 26, 27, 28, 29, 30, 31, 32, 33, 21, 21, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 21, 4, 48, 4, 4, 4
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214, 215, 213, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370, 386, 423, 423, 423, 415, 354, 346, 354, 346,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 440, 440, 440, 440, 440, 440, 440, 315, 354, 354, 354, 354, 354, 354, 354,
    354, 399, 423, 423, 424, 422, 423, 423, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 423, 423, 423, 423, 423,
    423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 353, 354, 354, 354,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 423, 50, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 15, 4, 16, 17, 18, 19, 20, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 21, 21,
    21, 21, 21, 21, 21, 23, 4, 24, 4, 21, 21, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 4, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 21, 21, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 21, 4, 48, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 21, 21, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 49, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 4, 21, 4, 21, 21, 4
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    2049, 2, 3, 4, 5, 2050, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3264, 3273, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938,
    3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547,
    3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 8043, 6905,
    3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891,
    9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3852, 7648, 3860, 3896, 3894, 3585, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934,
    3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7768, 6458, 3860, 3896,
    3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481,
    3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3927, 8013, 3860, 3896, 3894, 3638, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010,
    3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3687, 3702, 3860, 3896, 3894, 3876,
    3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511,
    3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 3912, 3951, 3860, 3896, 3894, 3995, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011,
    3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3822, 4027, 3860, 3896, 3894, 3289, 3489, 3336,
    3653, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529,
    3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 3837, 8278, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3600, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408,
    3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 6572, 7678, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495,
    3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540,
    3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 3717, 8440, 4061, 5456, 9680, 4058, 5649, 5649, 6173, 9679, 9679, 4077, 5649, 9149, 9679, 9679, 5639, 5649, 7613, 9679, 7353, 9656, 6417, 6757,
    5648, 4105, 7435, 9454, 9681, 4126, 4147, 7445, 8362, 4168, 8862, 9186, 8213, 4184, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7768, 8607, 4061, 5456, 9680, 4206, 5649, 5649, 6173, 9679, 9679, 4225,
    5649, 9149, 9679, 9679, 5639, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180,
    7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    8028, 9058, 3671, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431,
    9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7768, 8125, 4061, 5456, 5578, 4284, 5649, 5649, 6173, 9679, 9679, 4303, 5649, 9149,
    9679, 9679, 4331, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798,
    5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7267, 4619,
    3935, 4573, 4679, 4355, 4826, 4385, 4541, 4792, 4778, 4413, 4868, 4453, 4484, 4674, 4855, 4649, 4662, 4500, 4528, 4566, 4733, 4550, 4369, 4764, 4589, 4427,
    4605, 4635, 4695, 4719, 4749, 4808, 4842, 4819, 4703, 4881, 4397, 4437, 4512, 4897, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3732, 7693, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934,
    3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3747, 7708, 4922, 3896,
    3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481,
    3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3762, 7723, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010,
    3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 6448, 6458, 3860, 3896, 3894, 3289,
    3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511,
    3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7768, 4954, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011,
    3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 4061, 5456, 9680, 4985, 5649, 5649,
    6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613,
    9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 3966, 5542, 4061, 5456, 9680, 5022, 5649, 5649, 6694, 9679, 9679, 5059, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 5649,
    8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3777, 6458, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495,
    3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540,
    3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 3792, 7738, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569,
    3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 4468, 5087, 4287, 4089, 5118, 4985, 5649, 5649, 6694, 9679, 9679, 5945,
    5649, 9662, 9679, 9679, 5149, 6164, 8686, 9881, 5843, 5649, 5209, 6182, 6960, 8381, 5230, 5263, 5302, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180,
    7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    3966, 5542, 4061, 5456, 9680, 4985, 5649, 5649, 6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 8409, 5649, 6989, 9682, 5648, 8381,
    8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 4190, 9539, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 4042, 5350, 5381, 5334, 9703, 5415, 4237, 5649, 7161, 5431, 9679, 5945, 5453, 6686,
    7484, 8973, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 9548, 6808, 7109, 9744, 5759, 7544, 9930, 5647, 6655, 7613, 9189, 9272, 5472, 9180, 7617, 6798,
    7236, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 4969, 5497,
    4061, 5528, 8241, 5558, 5649, 4249, 7425, 9679, 5574, 5945, 5649, 9149, 9679, 9679, 7835, 5649, 8174, 9679, 7353, 6036, 8381, 7312, 6932, 5749, 8332, 9454,
    9681, 5649, 9679, 5647, 6655, 7613, 6327, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 5609, 5594, 4209, 5625, 5666, 5697, 7919, 5736, 6104, 5775, 8929, 5811, 5071, 5859, 5875, 5922,
    5961, 5977, 8524, 5993, 7353, 6032, 7982, 9682, 6052, 8381, 6089, 6129, 8893, 6145, 6198, 6231, 8094, 6267, 6314, 8652, 6343, 6382, 9752, 6407, 5720, 5937,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 8293, 6433, 4061, 6474,
    8732, 4985, 5649, 5649, 6694, 9679, 9679, 5945, 5649, 8807, 9679, 6515, 7322, 5649, 7613, 9679, 7353, 5649, 6510, 6366, 5648, 8381, 8332, 9454, 9681, 5649,
    9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 6541, 6531, 9578, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 6587, 6557, 4061, 5456, 9680, 4985, 5649, 5649, 6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649,
    7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 7214, 7473, 7330, 6113, 7613, 9189, 9186, 9183, 9180, 7617, 9004, 6603, 5937, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 9949, 5456, 6654, 6671,
    5649, 5650, 6694, 9679, 6073, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 4339,
    6638, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 5102, 6710, 8058, 5456, 6755, 6773, 6824, 5649, 4315, 6997, 9679, 6840, 5649, 5185, 9679, 7491, 8833, 5649, 9611, 9679,
    7353, 5649, 8381, 9682, 5481, 6876, 6921, 9818, 9358, 5649, 9679, 5647, 6655, 7613, 6391, 6954, 9183, 9180, 6976, 6798, 5720, 7013, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 8455, 7037, 4061, 7053, 7103, 4985, 7373, 5649,
    7125, 6208, 6215, 5945, 7150, 9149, 6618, 9679, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 9318, 6065, 8332, 9454, 4110, 8704, 4152, 5647, 6655, 7613,
    9189, 9186, 7940, 9642, 5712, 9120, 7187, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 5133, 7252, 4061, 7298, 7346, 4985, 7369, 8166, 7389, 9679, 7461, 5315, 7507, 9149, 5889, 7523, 6280, 7543, 7560, 9679, 7576, 5649,
    8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 8386, 8955, 7609, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 8622, 7633, 6725, 7793, 9217, 4985, 5649, 5649, 6694, 9679,
    9679, 5945, 5649, 9149, 9679, 9679, 9846, 9473, 4259, 6494, 7171, 7809, 5162, 7825, 5392, 8576, 8332, 6788, 7403, 7851, 7897, 7587, 7935, 7613, 8373, 7956,
    7909, 9180, 8504, 7972, 5720, 6008, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 5365, 7998, 10009, 8074, 8110, 4985, 5649, 6251, 6694, 9679, 8764, 9027, 5649, 8192, 9679, 9679, 8156, 5327, 7613, 6488, 7353, 5649, 8381, 9682,
    8190, 5000, 8332, 9454, 9681, 5649, 9679, 9451, 8208, 8229, 8484, 9186, 9183, 9180, 7617, 6798, 5720, 9019, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 9073, 8263, 4061, 5456, 9680, 4985, 9809, 5649, 6357, 8309, 7527, 5945,
    5649, 9149, 9679, 9679, 5276, 7081, 7613, 6633, 7353, 5399, 8381, 8328, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180,
    7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    3966, 5542, 4061, 8348, 8402, 4985, 5649, 5649, 6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381,
    8332, 9454, 9681, 5037, 8088, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 8140, 8425, 9732, 9856, 9889, 4985, 4131, 7087, 6694, 5899, 5789, 6016, 9800, 9149,
    8471, 9679, 5175, 6298, 8500, 4268, 7353, 5649, 8381, 9682, 5648, 8381, 8738, 9322, 9681, 5649, 9679, 5647, 8312, 8919, 8520, 9791, 8540, 9180, 7617, 8566,
    5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 5681, 8592,
    4061, 8638, 5836, 4985, 8678, 8702, 6860, 8720, 9679, 5945, 5649, 9149, 9679, 9679, 7414, 9508, 8754, 5906, 8787, 5247, 8381, 8823, 6289, 8849, 7202, 9454,
    9681, 6938, 5006, 5647, 6655, 8878, 9189, 9603, 8945, 8989, 9387, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7282, 9043, 7777, 9089, 9782, 9105, 9148, 9165, 7225, 5795, 7872, 7021, 5286, 5043, 9205, 9233,
    7322, 5649, 7863, 9679, 7067, 8550, 6739, 6891, 8799, 5824, 8247, 9249, 9288, 8662, 7881, 3979, 9304, 7613, 9189, 9186, 7134, 9338, 9374, 6798, 9395, 9411,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 5512, 9436, 4061, 5456,
    9680, 4985, 5649, 5649, 6694, 9679, 9679, 5945, 6246, 6852, 8964, 8771, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 9470, 9351, 8332, 9454, 9681, 5649,
    9679, 5240, 9264, 7613, 9189, 9186, 9183, 9489, 7617, 9132, 9524, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 4061, 9564, 9594, 9627, 9502, 5649, 5193, 9679, 9679, 5945, 9910, 9149, 9679, 9678, 7322, 5649,
    7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 4061, 5456, 9680, 4985,
    5649, 5649, 6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 6155, 9698, 9719, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647,
    6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 8907, 9768, 9834, 4985, 5649, 5649, 9872, 9679, 5437, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679,
    7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 3966, 5542, 4061, 7593, 5214, 4985, 5649, 5649,
    6694, 9679, 9679, 5945, 5649, 9149, 9679, 9679, 7322, 9905, 7613, 9926, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613,
    9189, 9186, 9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 3807, 7753, 3860, 3896, 3894, 3289, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408,
    3400, 3569, 3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7768, 9420, 4061, 5456, 9680, 9946, 5649, 5649, 6173, 9679,
    9679, 5945, 5649, 9149, 9679, 9679, 7322, 5649, 7613, 9679, 7353, 5649, 8381, 9682, 5648, 8381, 8332, 9454, 9681, 5649, 9679, 5647, 6655, 7613, 9189, 9186,
    9183, 9180, 7617, 6798, 5720, 5937, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 4906, 7663, 3860, 3896, 3894, 9965, 3489, 3336, 3614, 3495, 3342, 3304, 3320, 4938, 3316, 4934, 3371, 4010, 3445, 4011, 3358, 3408, 3400, 3569,
    3622, 3431, 9980, 3891, 9995, 3481, 3481, 3511, 3513, 3529, 3563, 3540, 3415, 3457, 3465, 3547, 3384, 3662, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 11287, 11287, 11287, 11287, 26, 11287, 11287, 11287, 11287, 11287,
    11287, 11287, 11287, 11287, 11287, 11287, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 135168, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141312, 136192, 0,
    0, 0, 171008, 180224, 0, 0, 202752, 0, 141312, 141312, 171008, 141312, 141312, 141312, 141312, 141312, 180224, 141312, 141312, 141312, 141312, 141312,
    141312, 141312, 190464, 141312, 141312, 141312, 141312, 194560, 141312, 198656, 141312, 200704, 201728, 141312, 141312, 204800, 141312, 207872, 141312,
    141312, 141312, 141312, 141312, 141312, 141312, 141312, 221184, 141312, 141312, 141312, 141312, 217088, 218112, 219136, 141312, 141312, 141312, 0, 0, 0, 0,
    224256, 141312, 141312, 141312, 0, 137216, 0, 0, 0, 0, 0, 141312, 141312, 174080, 141312, 141312, 141312, 141312, 215040, 141312, 189440, 210944, 141312,
    141312, 189440, 210944, 141312, 179200, 141312, 179200, 141312, 141312, 222208, 141312, 224256, 141312, 141312, 141312, 176128, 141312, 141312, 141312,
    141312, 141312, 186368, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 141312, 141312, 181248, 141312, 141312, 141312, 141312,
    212992, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 187392, 141312, 141312, 141312, 217088, 218112, 219136,
    141312, 141312, 141312, 141312, 141312, 174080, 141312, 141312, 141312, 141312, 141312, 181248, 141312, 141312, 141312, 141312, 141312, 141312, 216064,
    141312, 141312, 184320, 141312, 141312, 141312, 141312, 216064, 141312, 141312, 141312, 168960, 141312, 175104, 141312, 141312, 141312, 141312, 196608,
    141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 185344, 141312, 141312, 141312, 191488, 192512, 141312, 194560, 141312, 198656,
    141312, 200704, 201728, 0, 197632, 141312, 173056, 141312, 141312, 141312, 188416, 197632, 203776, 209920, 141312, 214016, 141312, 141312, 141312, 0,
    141312, 178176, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 223232, 141312, 178176, 141312, 141312, 141312, 141312, 141312, 141312, 0, 141312,
    141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 169984, 141312, 141312, 141312, 141312, 215040, 169984, 141312, 141312, 223232, 0, 141312,
    141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 222208, 141312, 224256, 0, 0, 187392, 135168, 26, 26, 29, 0, 0, 0,
    0, 0, 0, 0, 0, 207872, 0, 0, 141312, 136192, 260, 0, 0, 171008, 180224, 0, 0, 202752, 0, 141312, 141312, 171008, 141312, 141312, 141312, 221184, 141312,
    141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 187392, 141312, 141312, 141312, 141312, 208896, 141312, 135168, 26,
    26, 0, 30, 0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141312, 141312, 141312, 221184, 141312, 141312, 141312, 0, 8192, 141312, 141312, 141312, 141312, 141312,
    141312, 141312, 211968, 211968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25600, 141312, 141312, 141312, 141312, 24, 14360, 24, 24, 27, 24, 24, 24, 24, 24, 24, 24,
    14360, 24, 14360, 24, 24, 24, 14360, 14360, 24, 0, 0, 0, 143442, 143442, 143442, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528,
    22528, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 28707, 28707, 28707, 28707, 28707, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 30720, 30720, 30720, 30720, 30720, 0, 0, 0, 0, 26,
    0, 0, 0, 0, 0, 31780, 31780, 31780, 31780, 31780, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 35840, 35840, 35840, 35840, 35840, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 36864,
    36864, 36864, 36864, 36864, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 94208, 94208, 94208, 94208, 94208, 0, 0, 0, 0, 26, 0, 0, 0, 0, 18432, 17408, 17408, 17408, 17408,
    17408, 0, 0, 0, 0, 26, 0, 0, 0, 0, 20480, 19456, 19456, 19456, 19456, 19456, 0, 0, 0, 0, 26, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 141312,
    141312, 141312, 135168, 143442, 143442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141312, 141312, 182272, 141312, 141312, 141312, 141312, 141312, 141312,
    141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 141312, 141312, 0, 0, 16384, 0, 26, 16384, 16384, 16384, 16384, 0, 16384, 16384,
    16384, 16384, 16384, 0, 0, 0, 0, 26, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141407, 141407, 141407, 141407, 0, 0, 16384, 0, 16384, 16384, 0, 0, 0,
    26, 26, 26624, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 45, 45, 529, 45, 45, 45, 45, 45, 45, 45, 45, 535, 45, 45, 135168, 26, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141312, 141312, 183296, 141312, 141312, 141312, 141312, 193536, 141312, 141312, 199680, 141312, 205824, 141312, 141312,
    141312, 141312, 8254, 8254, 17408, 8254, 8254, 8254, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 47, 135168, 26, 26,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 45, 63, 136192, 260, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 120, 45, 124, 45, 127, 45, 45, 0,
    63, 63, 45, 45, 45, 444, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 497, 0, 499, 45, 45, 45, 502, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 45, 204, 45, 45, 45, 513, 63, 63, 63, 516, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 525, 63, 550, 45, 45, 45, 45, 555, 45, 45, 45, 63,
    559, 63, 63, 63, 63, 564, 45, 45, 45, 63, 615, 63, 63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 591, 592, 45, 594, 45, 135346, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 45, 45, 45, 101, 63, 136192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 197, 45, 45, 45, 45, 202, 45, 45, 45, 45, 45, 45, 209, 45,
    45, 211, 45, 45, 45, 45, 45, 45, 45, 45, 357, 63, 63, 63, 63, 63, 63, 63, 63, 371, 63, 63, 63, 63, 63, 63, 376, 81, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 45, 45, 98, 45, 63, 178, 261, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 223, 8416, 188, 63, 63, 63, 229, 63, 63, 63, 63, 63, 63, 261, 261, 0,
    0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 537, 135168, 0, 143443, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141407, 141407, 141407,
    141407, 141407, 141407, 141407, 141407, 187487, 141407, 141407, 141407, 141407, 208991, 141407, 194655, 141407, 198751, 141407, 200799, 201823, 141407,
    141407, 204895, 141407, 207967, 141407, 141407, 141407, 141407, 141407, 216159, 141449, 141449, 184457, 141449, 141449, 141449, 141449, 216201, 141407,
    141407, 141407, 141449, 136192, 0, 0, 0, 171008, 180224, 0, 0, 202752, 0, 141312, 141407, 171103, 141407, 141407, 182367, 141407, 141407, 141407, 141407,
    141407, 141407, 141407, 141407, 141407, 141407, 141449, 141449, 141449, 141449, 141449, 141449, 170079, 141407, 141407, 141407, 141407, 215135, 170121,
    202847, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 37,
    37, 37, 37, 37, 46, 141449, 171145, 141449, 141449, 141449, 141449, 141449, 180361, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 190601, 141449,
    183433, 141449, 141449, 141449, 141449, 193673, 141449, 141449, 199817, 141449, 205961, 141449, 141449, 141449, 141449, 215177, 141407, 189535, 211039,
    141407, 141449, 189577, 211081, 141449, 179295, 141407, 179337, 141449, 141449, 217225, 218249, 219273, 141449, 141449, 141449, 0, 0, 0, 0, 224256, 141407,
    141407, 141407, 221279, 141407, 141407, 141407, 0, 0, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 222345, 141449,
    224393, 0, 0, 187392, 176223, 141407, 141407, 141407, 141407, 141407, 186463, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407,
    141407, 141407, 141407, 141407, 136, 141449, 141449, 141449, 141449, 209033, 141449, 141449, 213129, 141449, 141449, 141449, 182272, 0, 0, 141407, 141407,
    141407, 177247, 177289, 141449, 141449, 182409, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 0, 0, 0, 0, 0, 0, 0, 15360,
    27648, 143443, 15360, 143443, 29, 30, 140288, 0, 169055, 141407, 175199, 141407, 141407, 141407, 141407, 196703, 141407, 141407, 141407, 141407, 141407,
    141407, 141407, 141407, 183391, 141407, 141407, 141407, 141407, 193631, 141407, 141407, 199775, 141407, 205919, 141407, 141407, 141407, 217183, 218207,
    219231, 141407, 141407, 141407, 141449, 141449, 174217, 141449, 141449, 141449, 141449, 202889, 141449, 141449, 141449, 141449, 141449, 141449, 141449,
    141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 0, 169097, 141449, 175241, 141449, 141449, 141449, 141449, 196745, 141449, 141449, 141449,
    141449, 141449, 141449, 141449, 141449, 141449, 0, 141407, 141407, 181343, 141407, 141407, 141407, 0, 197632, 141407, 173151, 141407, 141407, 141407,
    188511, 197727, 203871, 210015, 141407, 214111, 141407, 141407, 141407, 222303, 141407, 224351, 141449, 141449, 141449, 176265, 141449, 141449, 141449,
    141449, 141449, 186505, 141449, 141449, 173193, 141449, 141449, 141449, 188553, 197769, 203913, 210057, 141449, 214153, 141449, 141449, 141449, 0, 141407,
    213087, 141407, 141407, 141407, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 141449, 187529, 141449, 141449, 204937, 141449, 208009, 141449,
    141449, 141449, 141449, 141449, 141449, 141449, 141449, 221321, 141449, 141449, 141449, 185481, 141449, 141449, 141449, 191625, 192649, 141449, 194697,
    141449, 198793, 141449, 200841, 201865, 178271, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 223327, 141449, 178313, 141449, 141449, 141449,
    141449, 141449, 141449, 0, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 185439, 141407, 141407, 141407, 191583, 192607, 141407,
    141449, 141449, 223369, 0, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 141449, 141449, 141449, 0, 137216, 0, 0, 0, 0, 0, 141407,
    141407, 174175, 141407, 141407, 141407, 180319, 141407, 141407, 141407, 141407, 141407, 141407, 141407, 190559, 141407, 141407, 141407, 141407, 141449,
    141449, 181385, 141449, 141449, 141449, 141449, 141449, 141449, 216064, 141407, 141407, 184415, 141449, 141407, 141449, 141407, 141449, 141407, 141449,
    212063, 212105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3072, 3072, 3072, 3072, 3072, 0, 0, 13312, 29696, 32768, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 141312,
    141312, 202752, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 34816, 0, 34816,
    34816, 34816, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 38, 38, 38, 38, 38, 48, 0, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188,
    45, 45, 45, 45, 45, 446, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 523, 63, 63, 63, 179, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45,
    45, 503, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 294, 45, 45, 45, 8416, 63, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 275, 45, 45,
    278, 45, 45, 45, 45, 282, 45, 64, 64, 46, 64, 64, 64, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 40, 40, 40, 40, 40, 52, 140, 63, 63,
    63, 63, 63, 63, 63, 162, 63, 166, 63, 169, 63, 63, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 41, 41, 41, 41, 41, 54, 326, 63, 63, 0, 0, 0, 0, 0, 0, 0, 45, 45, 336,
    45, 45, 45, 45, 45, 63, 63, 63, 63, 409, 410, 63, 412, 63, 63, 63, 0, 0, 0, 0, 0, 332, 0, 45, 45, 45, 45, 45, 45, 45, 290, 45, 45, 45, 45, 45, 45, 45, 8416,
    188, 63, 63, 63, 63, 63, 63, 232, 45, 404, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 176, 63, 0, 63, 457, 63, 63, 63, 63, 63, 63, 63,
    0, 0, 0, 45, 45, 45, 45, 531, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 397, 45, 45, 45, 401, 45, 468, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 478, 45, 63,
    63, 63, 0, 0, 0, 0, 331, 0, 0, 45, 45, 45, 45, 45, 45, 45, 276, 45, 45, 45, 45, 45, 281, 45, 45, 63, 484, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 494, 63,
    0, 0, 262, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 345, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 128, 45, 45, 0, 63, 63, 65, 65, 47, 65, 65, 65, 0,
    0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 42, 42, 42, 42, 42, 56, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 434, 45, 45,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 398, 45, 45, 45, 45, 0, 26, 26, 0, 0, 0, 0, 0, 0, 184, 0, 0, 0, 0, 188, 189, 233, 63, 63, 63, 63, 238, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 256, 63, 63, 63, 45, 45, 272, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63, 63, 599, 63, 63, 63,
    63, 63, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 437, 45, 45, 45, 45, 441, 66, 66, 48, 66, 66, 66, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31,
    0, 0, 43, 43, 43, 43, 43, 61, 45, 45, 45, 112, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 45, 63, 63, 63, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 26, 26,
    0, 0, 0, 0, 182, 0, 0, 0, 186, 0, 0, 188, 190, 245, 63, 63, 247, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 178, 67, 67, 49, 67, 67, 67, 0,
    0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 32, 0, 39, 39, 39, 39, 39, 49, 45, 45, 110, 45, 117, 45, 121, 45, 45, 126, 129, 131, 45, 0, 63, 63,
    63, 0, 137216, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 217, 63, 143, 63, 63, 152, 63, 159, 63, 163, 63, 63, 168, 171,
    173, 63, 0, 0, 0, 0, 26, 0, 0, 31, 33, 0, 0, 0, 0, 0, 0, 59, 179, 26, 26, 0, 0, 180, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 628, 63, 63, 63, 63,
    63, 63, 63, 45, 45, 45, 45, 63, 63, 63, 63, 45, 45, 63, 45, 45, 45, 208, 45, 45, 45, 45, 45, 45, 45, 45, 213, 45, 45, 45, 45, 45, 63, 63, 63, 63, 450, 63,
    63, 63, 63, 63, 63, 63, 489, 490, 63, 63, 63, 63, 63, 0, 0, 63, 234, 63, 63, 237, 63, 63, 63, 63, 63, 63, 63, 63, 244, 63, 63, 63, 63, 63, 248, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 243, 63, 63, 63, 63, 63, 179, 0, 0, 263, 0, 0, 264, 265, 0, 0, 188, 267, 45, 45, 45, 45, 45, 63, 63, 63, 449, 63, 63, 452,
    63, 63, 63, 63, 63, 157, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 383, 0, 0, 0, 45, 45, 45, 45, 284, 285, 286, 45, 45, 45, 45, 291, 45, 293, 45, 45, 296, 45,
    8416, 298, 63, 63, 63, 63, 63, 63, 63, 63, 63, 306, 63, 63, 309, 63, 63, 63, 63, 63, 302, 63, 63, 63, 305, 63, 63, 63, 63, 63, 63, 240, 63, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 372, 63, 63, 63, 63, 63, 63, 63, 313, 63, 63, 315, 316, 317, 63, 63, 63, 63, 322, 63, 324, 63, 45, 63, 45, 63, 45, 63, 45, 63, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 63, 327, 63, 0, 0, 329, 0, 0, 0, 0, 45, 45, 45, 45, 338, 339, 45, 341, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 350, 351, 365, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 374, 375, 63, 45, 63, 45, 63, 664, 665, 45, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45,
    45, 268, 45, 45, 45, 45, 391, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 400, 45, 45, 428, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 439, 45, 45,
    45, 45, 45, 63, 63, 448, 63, 63, 63, 63, 63, 63, 63, 63, 63, 253, 63, 63, 63, 63, 63, 63, 456, 63, 63, 63, 63, 63, 63, 63, 63, 0, 463, 0, 45, 45, 467, 45,
    45, 45, 45, 221, 45, 45, 8416, 188, 63, 63, 63, 63, 63, 63, 63, 63, 63, 544, 63, 63, 63, 63, 0, 45, 45, 45, 45, 470, 45, 472, 45, 45, 45, 45, 477, 479, 45,
    63, 63, 483, 45, 500, 45, 45, 45, 45, 45, 45, 45, 506, 45, 45, 45, 45, 45, 45, 45, 45, 395, 45, 45, 45, 45, 45, 45, 45, 45, 346, 45, 45, 45, 45, 45, 45, 45,
    0, 0, 63, 63, 63, 63, 63, 63, 63, 63, 63, 424, 63, 63, 63, 0, 0, 0, 63, 514, 63, 63, 63, 63, 63, 63, 63, 520, 63, 63, 63, 63, 63, 63, 239, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 254, 63, 63, 63, 63, 63, 527, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 536, 45, 45, 45, 45, 273, 45, 45, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 214, 45, 45, 45, 45, 45, 552, 45, 45, 45, 45, 45, 45, 63, 63, 63, 561, 63, 63, 63, 0, 0, 0, 330, 0, 0, 0, 45, 45, 45, 45, 45, 45,
    45, 436, 45, 45, 45, 45, 45, 45, 45, 45, 45, 347, 45, 45, 45, 45, 45, 45, 63, 63, 63, 567, 45, 45, 45, 45, 45, 45, 45, 45, 576, 63, 63, 63, 0, 45, 45, 570,
    45, 45, 45, 45, 45, 45, 63, 63, 579, 63, 63, 598, 63, 63, 63, 63, 63, 63, 0, 606, 45, 45, 608, 45, 45, 45, 45, 45, 222, 45, 8416, 188, 63, 63, 63, 63, 63,
    63, 63, 63, 423, 63, 63, 63, 63, 0, 0, 0, 45, 45, 45, 614, 63, 63, 616, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 572, 573, 574, 575, 45, 63, 63, 63, 45, 45,
    639, 63, 641, 63, 63, 63, 645, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 413, 63, 63, 68, 68, 50, 68, 68, 68, 0, 0, 0, 26, 26, 26, 29, 30, 31,
    0, 0, 0, 0, 26, 0, 33792, 0, 0, 33792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 45, 45, 45, 113, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63,
    63, 63, 63, 63, 369, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 373, 63, 63, 63, 403, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
    63, 323, 63, 63, 45, 45, 45, 640, 63, 63, 63, 63, 63, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 634, 45, 45, 69, 69, 51, 69, 69, 69, 0, 0, 0,
    26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 21504, 0, 0, 0, 0, 21504, 21504, 21504, 21504, 21504, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 51, 63, 651,
    652, 63, 63, 45, 45, 45, 45, 63, 63, 63, 63, 45, 45, 63, 63, 63, 63, 301, 63, 63, 63, 63, 63, 63, 63, 63, 63, 310, 63, 63, 63, 63, 368, 63, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 547, 0, 45, 141, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 0, 26, 26, 0, 0, 0, 181, 0, 0, 0, 0, 0, 0,
    0, 188, 45, 45, 45, 45, 287, 288, 45, 45, 45, 45, 45, 45, 45, 45, 45, 8416, 188, 63, 63, 63, 63, 63, 63, 63, 70, 70, 52, 70, 70, 70, 0, 0, 0, 26, 26, 26,
    29, 30, 31, 0, 0, 0, 0, 88, 0, 0, 91, 0, 0, 94, 0, 45, 96, 45, 45, 45, 45, 45, 406, 63, 63, 63, 63, 63, 63, 63, 63, 63, 414, 63, 144, 63, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 0, 427, 0, 0, 26, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 188, 45, 45, 45, 45, 471, 45, 45, 45, 475, 45, 45, 45, 45, 63, 63,
    63, 63, 63, 63, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 455, 45, 45, 193, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 205, 259,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 45, 45, 45, 45, 45, 45, 289, 45, 45, 45, 45, 45, 45, 45, 45, 8416, 188, 63, 63, 228, 63, 63, 231, 63, 45, 45, 443, 45,
    445, 63, 63, 63, 63, 63, 63, 63, 63, 63, 454, 63, 63, 63, 63, 419, 63, 63, 63, 63, 63, 63, 63, 63, 426, 0, 0, 0, 0, 0, 34, 0, 0, 0, 26, 26, 26, 29, 30,
    140288, 0, 63, 63, 63, 458, 63, 63, 460, 63, 462, 0, 0, 0, 45, 45, 45, 45, 433, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 509, 45, 45, 45, 63, 581,
    582, 583, 584, 63, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 440, 45, 45, 624, 625, 45, 45, 45, 63, 63, 63, 630, 631, 63, 63, 63, 45, 45, 45, 45,
    45, 63, 407, 408, 63, 63, 63, 63, 63, 63, 63, 63, 63, 241, 63, 63, 63, 63, 63, 63, 63, 660, 661, 45, 63, 45, 63, 45, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188,
    45, 45, 45, 269, 71, 71, 53, 71, 71, 71, 0, 0, 0, 26, 26, 26, 29, 30, 31, 86, 104, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63, 63,
    379, 63, 63, 0, 0, 384, 0, 0, 386, 45, 45, 45, 45, 45, 344, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 212, 45, 45, 45, 45, 63, 63, 146, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 464, 45, 45, 45, 45, 218, 45, 45, 45, 45, 45, 45, 8416, 188, 63, 63, 63, 63, 63, 63, 63, 63, 63, 605, 45, 45, 45, 45,
    45, 45, 270, 45, 45, 45, 45, 45, 45, 45, 45, 45, 279, 45, 45, 45, 45, 45, 45, 45, 8416, 188, 225, 63, 63, 63, 63, 63, 63, 63, 381, 382, 0, 0, 0, 0, 45, 45,
    45, 650, 63, 63, 63, 63, 45, 45, 45, 45, 63, 63, 63, 63, 45, 45, 63, 63, 63, 63, 459, 63, 63, 63, 63, 0, 0, 0, 45, 45, 45, 45, 45, 45, 504, 45, 45, 45, 507,
    45, 45, 45, 45, 45, 45, 45, 8416, 188, 63, 227, 63, 63, 63, 63, 63, 45, 45, 45, 655, 63, 63, 63, 657, 45, 45, 63, 72, 72, 54, 72, 72, 72, 0, 0, 0, 26, 26,
    26, 29, 30, 31, 0, 0, 0, 25, 28, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 60, 105, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 45, 45, 0, 63, 63, 63, 63, 63, 420, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 534, 45, 45, 45, 45, 63, 63,
    147, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 194, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 203, 45,
    45, 45, 45, 219, 45, 45, 45, 45, 45, 8416, 188, 63, 63, 63, 63, 230, 63, 63, 63, 63, 63, 487, 63, 63, 63, 491, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 334, 45,
    45, 45, 45, 45, 45, 45, 8416, 188, 226, 63, 63, 63, 63, 63, 63, 63, 461, 63, 0, 0, 0, 45, 45, 45, 45, 45, 532, 45, 45, 533, 45, 45, 45, 45, 45, 63, 246, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 255, 63, 63, 63, 63, 63, 63, 518, 63, 63, 63, 521, 63, 63, 63, 63, 63, 63, 303, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
    321, 63, 63, 63, 63, 45, 271, 45, 45, 45, 274, 45, 45, 45, 45, 45, 45, 45, 45, 45, 283, 63, 63, 63, 314, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
    63, 63, 258, 340, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 512, 45, 45, 354, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 364, 63,
    378, 63, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 45, 45, 45, 530, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 134, 45, 0, 63, 63, 63, 566, 63, 0, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 45, 45, 45, 73, 73, 55, 73, 73, 73, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 29, 29, 0, 0, 0, 0, 26,
    26, 26, 7252, 30, 140288, 0, 0, 0, 0, 0, 3072, 0, 0, 0, 0, 0, 0, 0, 0, 140288, 0, 0, 0, 0, 0, 21504, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 0,
    28707, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 0, 31780, 0, 0, 0, 26, 26, 26, 29, 30,
    140288, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 0, 94208, 0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 97, 45, 45, 45, 45, 45, 114, 45, 45, 45, 45, 45, 45, 45, 45, 135, 0, 63, 138, 45, 389, 390, 45, 392, 45, 45, 45, 45,
    396, 45, 45, 45, 45, 45, 402, 63, 416, 63, 63, 63, 63, 63, 422, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 337, 45, 45, 45, 45, 45, 501, 45, 45,
    45, 45, 45, 45, 45, 508, 45, 45, 45, 45, 45, 45, 355, 45, 45, 63, 63, 63, 63, 63, 63, 63, 251, 252, 63, 63, 63, 63, 63, 63, 63, 63, 519, 63, 63, 63, 63,
    524, 63, 63, 63, 63, 63, 515, 63, 63, 63, 63, 63, 63, 63, 522, 63, 63, 63, 63, 63, 63, 602, 63, 604, 0, 45, 45, 45, 45, 45, 45, 45, 198, 45, 45, 201, 45,
    45, 45, 45, 45, 63, 63, 63, 540, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 609, 610, 580, 63, 63, 63, 63, 63, 586, 45, 45, 45, 45, 45, 45,
    593, 45, 595, 637, 45, 45, 63, 63, 642, 643, 63, 63, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 411, 63, 63, 63, 63, 74, 74, 56, 74, 74, 74, 0, 0, 0,
    26, 26, 26, 29, 30, 31, 0, 0, 0, 30, 30, 0, 0, 0, 0, 26, 26, 26, 29, 7253, 140288, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 24620, 24620, 24620, 24620, 0, 0, 0, 0,
    26, 0, 0, 0, 0, 0, 34, 34, 34, 34, 34, 0, 0, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 45, 45, 45, 102, 45, 109, 45, 45, 45, 119, 122, 45, 45, 45, 130, 132, 45, 0, 63,
    63, 63, 63, 63, 517, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 546, 63, 0, 45, 142, 145, 63, 151, 63, 63, 63, 161, 164, 63, 63, 63, 172, 174, 63, 0,
    0, 0, 81, 81, 0, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 58, 63, 63, 328, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45,
    45, 45, 210, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 63, 361, 63, 63, 63, 0, 429, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 297, 8416,
    538, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 607, 45, 45, 45, 45, 45, 551, 45, 45, 45, 45, 45, 45, 45, 63, 63, 560, 63, 63, 63, 63, 63,
    154, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 45, 466, 45, 45, 75, 75, 57, 75, 75, 75, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 19456, 19456, 19456, 0,
    0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 50, 63, 63, 236, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0,
    549, 63, 63, 63, 418, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 45, 45, 45, 45, 106, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63,
    63, 542, 63, 63, 543, 63, 63, 63, 63, 63, 0, 45, 45, 45, 571, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 548, 45, 63, 63,
    148, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 45, 387, 388, 76, 76, 58, 76, 76, 76, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 22528,
    22528, 22528, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 53, 63, 63, 299, 63, 63, 63, 63, 63, 63, 63, 63, 63, 308, 63,
    63, 63, 0, 45, 569, 45, 45, 45, 45, 45, 45, 45, 63, 578, 63, 352, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 63, 45, 45, 636, 565, 63, 63,
    0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 362, 363, 63, 63, 597, 63, 63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 45, 45, 45, 394, 45, 45, 45,
    45, 399, 45, 45, 45, 45, 638, 45, 63, 63, 63, 63, 644, 63, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 451, 63, 63, 63, 63, 63, 77, 77, 59, 77, 77, 77, 0,
    0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 23632, 23632, 0, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 55, 45, 45, 45, 115,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63, 63, 585, 0, 45, 45, 589, 45, 45, 45, 45, 45, 45, 45, 45, 505, 45, 45, 45, 45, 510, 45, 45, 45, 192,
    45, 45, 195, 45, 45, 199, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 360, 63, 63, 63, 63, 45, 206, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    511, 45, 63, 235, 63, 63, 63, 63, 63, 63, 63, 63, 63, 242, 63, 63, 63, 63, 63, 155, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 465, 45, 45, 45, 45, 353,
    45, 45, 45, 45, 45, 356, 45, 358, 63, 63, 63, 63, 63, 63, 250, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 320, 63, 63, 63, 63, 63, 377, 63, 63, 63, 63, 63,
    380, 63, 0, 0, 0, 385, 0, 45, 45, 45, 432, 45, 45, 435, 45, 45, 45, 45, 45, 45, 45, 45, 45, 292, 45, 45, 45, 45, 45, 8416, 63, 63, 417, 63, 63, 63, 421, 63,
    63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 45, 335, 45, 45, 45, 45, 442, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63, 453, 63, 63, 63, 0, 568, 45, 45, 45, 45,
    45, 45, 45, 45, 577, 63, 63, 45, 45, 45, 553, 554, 45, 45, 45, 45, 63, 63, 63, 63, 562, 563, 63, 63, 63, 63, 486, 63, 488, 63, 63, 63, 63, 493, 495, 63, 0,
    0, 0, 0, 0, 0, 90, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 556, 45, 45, 558, 63, 63, 63, 63, 63, 63, 249, 63, 63, 63, 63, 63, 63, 63, 257, 63, 596, 63, 63,
    63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 45, 45, 45, 557, 45, 63, 63, 63, 63, 63, 63, 63, 63, 304, 63, 63, 63, 63, 63, 63, 63, 63, 318, 319, 63, 63, 63,
    63, 63, 63, 611, 45, 45, 63, 63, 63, 63, 63, 63, 619, 63, 63, 0, 45, 623, 45, 45, 45, 63, 63, 63, 63, 63, 63, 45, 45, 647, 648, 45, 45, 63, 45, 63, 662,
    663, 45, 63, 45, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 188, 45, 45, 45, 45, 78, 78, 60, 78, 78, 78, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 0, 24620, 24620, 0,
    0, 0, 0, 26, 26, 26, 29, 30, 140288, 0, 0, 0, 0, 26, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 57, 45, 45, 111, 116, 118, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 139,
    0, 26, 26, 0, 0, 0, 0, 0, 0, 0, 185, 0, 0, 0, 188, 45, 45, 45, 63, 63, 63, 63, 63, 63, 45, 646, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 45, 45, 45, 45, 649,
    45, 63, 191, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 8416, 45, 207, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 215, 216, 45, 45, 45,
    63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 300, 63, 63, 63, 63, 63, 63, 63, 307, 63, 63, 63, 63, 63,
    156, 63, 63, 63, 63, 63, 63, 63, 63, 177, 0, 63, 312, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 325, 45, 469, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 480, 63, 482, 63, 63, 63, 63, 541, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 45, 45, 590, 45, 45, 45, 45, 45, 63, 63, 485, 63, 63, 63, 63, 63, 63, 63,
    63, 63, 63, 496, 0, 498, 63, 63, 539, 63, 63, 63, 63, 63, 63, 63, 63, 545, 63, 63, 0, 45, 45, 431, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 481,
    63, 63, 45, 45, 613, 63, 63, 63, 63, 63, 63, 63, 63, 621, 0, 45, 45, 45, 45, 45, 63, 447, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 492, 63, 63, 63, 0, 0, 45,
    45, 626, 627, 45, 63, 63, 63, 63, 63, 632, 633, 63, 45, 45, 45, 45, 45, 63, 629, 63, 63, 63, 63, 63, 63, 45, 45, 45, 45, 63, 63, 63, 63, 45, 658, 63, 659,
    45, 63, 45, 63, 45, 63, 45, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 79, 79, 61, 79, 79, 79, 0, 0, 0, 26, 26, 26, 29, 30, 31, 0, 0, 528,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 63, 63, 0, 45, 430, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 349, 45, 45, 45, 612, 45,
    63, 63, 63, 63, 63, 63, 63, 620, 63, 0, 45, 45, 45, 45, 45, 196, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 348, 45, 45, 45, 45, 63, 63, 63, 653, 63, 45,
    45, 45, 45, 63, 63, 63, 63, 45, 45, 63, 63, 63, 63, 600, 601, 63, 603, 63, 0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 438, 45, 45, 45, 45, 107, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63, 63, 654, 45, 45, 45, 656, 63, 63, 63, 45, 45, 63, 63, 63, 149, 63, 63, 63, 63, 63, 63, 63, 63, 63,
    63, 63, 63, 0, 587, 45, 45, 45, 45, 45, 45, 45, 45, 45, 63, 359, 63, 63, 63, 63, 63, 0, 26, 26, 0, 0, 0, 0, 0, 183, 0, 0, 0, 0, 0, 188, 45, 45, 45, 63, 63,
    63, 63, 617, 618, 63, 63, 63, 0, 622, 45, 45, 45, 45, 45, 393, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 295, 45, 45, 8416, 311, 63, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 45, 45, 45, 405, 45, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 170, 63, 63, 0, 415, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 425, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 93, 0, 0, 45, 45, 45, 45, 45, 45, 473, 474, 45, 45, 45, 45, 45, 63, 63, 63, 63, 63, 63, 63,
    63, 45, 635, 45, 108, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 0, 63, 63, 63, 63, 153, 158, 160, 63, 63, 63, 63, 63, 63, 63, 63, 0, 45, 588, 45, 45,
    45, 45, 45, 45, 45, 45, 277, 45, 45, 45, 45, 45, 45, 45, 45, 200, 45, 45, 45, 45, 45, 45, 45, 45, 45, 476, 45, 45, 45, 63, 63, 63, 63, 63, 150, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 333, 45, 45, 45, 45, 45, 45, 45, 123, 125, 45, 45, 133, 45, 0, 63, 63, 45, 45, 220, 45, 45, 45, 45,
    8416, 188, 63, 63, 63, 63, 63, 63, 63, 370, 63, 63, 63, 63, 63, 63, 63, 63, 63, 165, 167, 63, 63, 175, 63, 0, 45, 45, 45, 342, 343, 45, 45, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 280, 45, 45, 45, 63, 63, 366, 367, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 526, 0, 26, 26, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 45, 45, 99, 45, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207872, 0, 0, 141312, 141312, 208896, 141312, 141312, 212992, 141312, 141312,
    141312, 182272, 0, 0, 141312, 141312, 141312, 177152, 141312, 141312, 182272, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
    141312, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 45, 45, 100, 103
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    250, 254, 258, 262, 266, 275, 399, 401, 332, 333, 272, 268, 399, 399, 399, 399, 400, 332, 332, 332, 332, 332, 279, 397, 399, 399, 399, 400, 332, 332, 332,
    332, 292, 302, 399, 399, 399, 331, 332, 332, 332, 396, 399, 399, 329, 332, 332, 299, 398, 399, 329, 332, 332, 301, 399, 329, 332, 306, 399, 399, 332, 332,
    302, 399, 332, 316, 399, 331, 321, 329, 316, 399, 332, 322, 330, 317, 329, 326, 330, 328, 326, 337, 341, 345, 351, 355, 379, 359, 380, 364, 379, 363, 379,
    530, 368, 592, 288, 377, 379, 379, 591, 287, 376, 379, 379, 531, 384, 593, 392, 379, 379, 386, 390, 394, 379, 530, 405, 409, 267, 379, 419, 413, 378, 379,
    417, 423, 432, 566, 423, 432, 530, 427, 431, 566, 429, 378, 436, 442, 566, 446, 379, 438, 378, 438, 378, 607, 450, 608, 379, 539, 538, 370, 456, 540, 459,
    372, 371, 542, 541, 456, 456, 461, 462, 463, 562, 565, 379, 295, 467, 379, 309, 471, 452, 484, 451, 483, 529, 488, 379, 379, 347, 493, 498, 529, 379, 346,
    492, 497, 505, 588, 379, 379, 283, 502, 529, 379, 281, 285, 504, 509, 379, 581, 286, 528, 379, 474, 518, 522, 379, 573, 526, 379, 573, 526, 535, 572, 477,
    379, 574, 479, 379, 546, 379, 550, 571, 554, 559, 554, 570, 554, 559, 555, 310, 578, 585, 599, 311, 310, 597, 604, 600, 312, 599, 599, 512, 513, 514, 612,
    615, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 721, 749, 642, 758, 756, 783, 693, 723, 723, 723, 657, 654, 750, 751, 723, 672, 657, 657,
    652, 753, 723, 723, 679, 646, 690, 773, 776, 778, 780, 649, 799, 644, 645, 753, 723, 676, 711, 711, 644, 644, 659, 723, 657, 657, 657, 644, 644, 644, 723,
    676, 723, 723, 696, 675, 676, 644, 644, 644, 767, 657, 644, 659, 657, 657, 657, 644, 644, 656, 657, 657, 658, 644, 644, 644, 644, 652, 658, 644, 656, 658,
    656, 656, 656, 656, 659, 723, 723, 724, 742, 744, 674, 664, 665, 665, 669, 668, 667, 671, 766, 723, 757, 648, 683, 685, 650, 687, 723, 647, 782, 723, 723,
    752, 697, 793, 723, 799, 703, 694, 723, 723, 723, 723, 683, 782, 723, 754, 759, 771, 763, 776, 675, 699, 661, 692, 694, 723, 723, 767, 657, 657, 657, 657,
    768, 644, 782, 754, 770, 762, 764, 675, 699, 661, 765, 792, 781, 702, 674, 660, 723, 755, 771, 763, 761, 763, 765, 699, 782, 755, 718, 764, 735, 661, 694,
    723, 723, 723, 766, 754, 760, 764, 736, 763, 765, 736, 694, 718, 764, 735, 662, 737, 723, 723, 723, 726, 716, 793, 723, 723, 733, 698, 673, 723, 733, 673,
    723, 709, 712, 713, 713, 714, 724, 717, 740, 723, 679, 759, 772, 775, 777, 795, 678, 723, 716, 720, 728, 730, 740, 676, 723, 732, 739, 744, 646, 769, 761,
    746, 746, 777, 779, 700, 794, 776, 778, 780, 794, 740, 723, 676, 676, 748, 723, 723, 696, 766, 723, 696, 766, 775, 777, 779, 785, 798, 677, 724, 740, 775,
    777, 794, 740, 723, 723, 723, 766, 647, 676, 725, 723, 723, 707, 698, 673, 723, 723, 733, 698, 787, 773, 777, 795, 724, 681, 697, 789, 723, 787, 773, 765,
    797, 797, 723, 723, 723, 709, 723, 722, 723, 723, 723, 755, 797, 678, 723, 723, 723, 787, 772, 775, 675, 795, 723, 723, 724, 680, 690, 696, 675, 790, 723,
    732, 740, 723, 689, 771, 763, 776, 675, 675, 723, 723, 695, 734, 676, 723, 734, 791, 723, 723, 752, 705, 698, 737, 695, 722, 695, 722, 774, 774, 774, 722,
    17408, 25600, 50176, 67126272, 33572864, 1098752, 50176, 50496, 50176, 672768, -130690044, -105524220, -105516028, -38415356, -38407164, 17920, 18048,
    18048, 116224, 31745784, 31778552, -130754940, 18432, 33556480, 640, 640, 32, 64, 32768, 4194304, 58720256, 201326592, 640, 48, 56, 2048, 640, 512, 512,
    640, 0, 4194304, 25165824, -2147483648, 1, 4227148, 4227148, -1073741966, -1073741966, -1073741968, -1073741968, -1073741958, 0, 16777216, 0, 131072,
    262144, 0, 262144, 1, 4, 64, 12288, 368, 7680, 122880, 8257536, -1342177280, 0, 112, 256, 2048, 33554432, 268435456, -2147483648, 0, 8192, 16384, 65536,
    524288, 2097152, 8388608, 25165824, 268435456, 536870912, 256, 24576, 32, 24576, 16384, 16777216, 201327649, 201327649, 130022911, 130022911, 264240639, 24,
    32, 1024, 4096, 448, 1024, 16384, 0, 0, 1, 0, 7, 30720, 32768, 2031616, 60817408, 1, 32, 16384, 131072, 524288, 25165824, 0, 1024, 67108864, 0, 2, 4, 8, 16,
    28672, 32768, 1, 67108864, 2048, 64, 0, 32, 0, 48, 256, 0, 64, 64, 256, 1024, 2048, 4096, 24576, 65536, 131072, 0, 512, 128, 256, 1536, 2048, 12288, 16384,
    16384, 32768, 65536, 393216, 524288, 1048576, 2097152, 4194304, 0, 4096, 2097152, 16777216, 1, 64, 393216, 33554432, 262144, 262144, 524288, 16777216,
    33554432, 0, 262144, 33554432, 67108864, 134217728
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'END',
    'EOF',
    'IntegerLiteral',
    'DecimalLiteral',
    'DoubleLiteral',
    'StringLiteral',
    'Wildcard',
    'NCName',
    'QName',
    'S',
    'CommentContents',
    &quot;'!='&quot;,
    &quot;'('&quot;,
    &quot;'(:'&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'/'&quot;,
    &quot;'//'&quot;,
    &quot;':)'&quot;,
    &quot;'::'&quot;,
    &quot;'&lt;'&quot;,
    &quot;'&lt;='&quot;,
    &quot;'='&quot;,
    &quot;'&gt;'&quot;,
    &quot;'&gt;='&quot;,
    &quot;'?'&quot;,
    &quot;'@'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'ancestor'&quot;,
    &quot;'ancestor-or-self'&quot;,
    &quot;'and'&quot;,
    &quot;'as'&quot;,
    &quot;'attribute'&quot;,
    &quot;'cast'&quot;,
    &quot;'castable'&quot;,
    &quot;'child'&quot;,
    &quot;'comment'&quot;,
    &quot;'descendant'&quot;,
    &quot;'descendant-or-self'&quot;,
    &quot;'div'&quot;,
    &quot;'document-node'&quot;,
    &quot;'element'&quot;,
    &quot;'else'&quot;,
    &quot;'empty-sequence'&quot;,
    &quot;'eq'&quot;,
    &quot;'every'&quot;,
    &quot;'except'&quot;,
    &quot;'following'&quot;,
    &quot;'following-sibling'&quot;,
    &quot;'for'&quot;,
    &quot;'ge'&quot;,
    &quot;'gt'&quot;,
    &quot;'idiv'&quot;,
    &quot;'if'&quot;,
    &quot;'in'&quot;,
    &quot;'instance'&quot;,
    &quot;'intersect'&quot;,
    &quot;'is'&quot;,
    &quot;'item'&quot;,
    &quot;'le'&quot;,
    &quot;'lt'&quot;,
    &quot;'mod'&quot;,
    &quot;'namespace'&quot;,
    &quot;'ne'&quot;,
    &quot;'node'&quot;,
    &quot;'of'&quot;,
    &quot;'or'&quot;,
    &quot;'parent'&quot;,
    &quot;'preceding'&quot;,
    &quot;'preceding-sibling'&quot;,
    &quot;'processing-instruction'&quot;,
    &quot;'return'&quot;,
    &quot;'satisfies'&quot;,
    &quot;'schema-attribute'&quot;,
    &quot;'schema-element'&quot;,
    &quot;'self'&quot;,
    &quot;'some'&quot;,
    &quot;'text'&quot;,
    &quot;'then'&quot;,
    &quot;'to'&quot;,
    &quot;'treat'&quot;,
    &quot;'typeswitch'&quot;,
    &quot;'union'&quot;,
    &quot;'|'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 1024, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 1024"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 16"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 6)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="1024 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 16"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 1023) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 2">
        <xsl:variable name="i0" select=". * 665 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 2"/>
        <xsl:variable name="i2" select="$i1 idiv 4"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[6 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[12 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production Comment (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(4, $input, $state)"/>       <!-- CommentContents | ('(' ':') | (':' ')') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 25">                                      <!-- (':' ')') -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 11">                                <!-- CommentContents -->
                  <xsl:variable name="state" select="p:consumeT(11, $input, $state)"/> <!-- CommentContents -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Comment($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:try-Comment-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing Comment.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:consumeT(14, $input, $state)"/>            <!-- ('(' ':') -->
    <xsl:variable name="state" select="p:try-Comment-1($input, $state)"/>
    <xsl:variable name="state" select="p:consumeT(25, $input, $state)"/>            <!-- (':' ')') -->
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production WhiteSpace (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-WhiteSpace-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:error]">
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = 10">                                    <!-- S^WhiteSpace -->
              <xsl:variable name="state" select="p:consumeT(10, $input, $state)"/>  <!-- S^WhiteSpace -->
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:variable name="state" select="
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Comment($input, $state)
              "/>
              <xsl:sequence select="$state"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="state" select="p:lookahead1(0, $input, $state)"/>       <!-- END | S^WhiteSpace | ('(' ':') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 1">                                       <!-- END -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:try-WhiteSpace-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing WhiteSpace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-WhiteSpace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:try-WhiteSpace-1($input, $state)"/>
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Parse AtomicType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AtomicType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-QName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AtomicType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (40,                                          (: 'attribute' :)
                                         48,                                          (: 'document-node' :)
                                         49,                                          (: 'element' :)
                                         66,                                          (: 'item' :)
                                         72,                                          (: 'node' :)
                                         78,                                          (: 'processing-instruction' :)
                                         81,                                          (: 'schema-attribute' :)
                                         82,                                          (: 'schema-element' :)
                                         85)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(5, $input, $state)"/>    <!-- END | S^WhiteSpace | '(' | ('(' ':') -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1704                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 1712                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 1713                                          (: 'element' '(' :)
                     or $state[$p:lk] = 1736                                          (: 'node' '(' :)
                     or $state[$p:lk] = 1742                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 1745                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 1746                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 1749">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1730">                                      <!-- 'item' '(' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'item' -->
          <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>    <!-- S^WhiteSpace | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(13, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(15, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AtomicType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse OccurrenceIndicator.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WhiteSpace | ('(' ':') | '*' | '+' | '?' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 32">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- '+' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OccurrenceIndicator', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 33">                                        <!-- '@' -->
          <xsl:variable name="state" select="p:consume(33, $input, $state)"/>       <!-- '@' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>         <!-- Wildcard | QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NodeTest($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- Wildcard -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- Wildcard -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyKindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyKindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'node' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyKindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TextTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TextTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(85, $input, $state)"/>             <!-- 'text' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TextTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaAttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaAttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(81, $input, $state)"/>             <!-- 'schema-attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaAttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PITest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PITest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(78, $input, $state)"/>             <!-- 'processing-instruction' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(8, $input, $state)"/>          <!-- StringLiteral | NCName | S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 8">                                   <!-- NCName -->
                <xsl:variable name="state" select="p:consume(8, $input, $state)"/>  <!-- NCName -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(6, $input, $state)"/>  <!-- StringLiteral -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PITest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-QName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttribNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttribNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(16, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttribNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- 'attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- QName^Token | S^WhiteSpace | ('(' ':') | ')' | '*' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttribNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 20">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/> <!-- QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                             'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                             'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                             'every' | 'except' | 'following' | 'following-sibling' | 'for' |
                                                                                             'ge' | 'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                                                             'item' | 'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' |
                                                                                             'parent' | 'preceding' | 'preceding-sibling' |
                                                                                             'processing-instruction' | 'return' | 'satisfies' |
                                                                                             'schema-attribute' | 'schema-element' | 'self' | 'some' | 'text' |
                                                                                             'to' | 'treat' | 'typeswitch' | 'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(82, $input, $state)"/>             <!-- 'schema-element' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-QName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse QName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'comment' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'document-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'element' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'if' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'if' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'item' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'item' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 72">                                        <!-- 'node' -->
          <xsl:variable name="state" select="p:consume(72, $input, $state)"/>       <!-- 'node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'processing-instruction' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'schema-attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'schema-element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 85">                                        <!-- 'text' -->
          <xsl:variable name="state" select="p:consume(85, $input, $state)"/>       <!-- 'text' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'typeswitch' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'typeswitch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-QName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(16, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(49, $input, $state)"/>             <!-- 'element' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- QName^Token | S^WhiteSpace | ('(' ':') | ')' | '*' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 20">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/> <!-- QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                             'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                             'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                             'every' | 'except' | 'following' | 'following-sibling' | 'for' |
                                                                                             'ge' | 'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                                                             'item' | 'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' |
                                                                                             'parent' | 'preceding' | 'preceding-sibling' |
                                                                                             'processing-instruction' | 'return' | 'satisfies' |
                                                                                             'schema-attribute' | 'schema-element' | 'self' | 'some' | 'text' |
                                                                                             'to' | 'treat' | 'typeswitch' | 'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/> <!-- S^WhiteSpace | ('(' ':') | ')' | '?' -->
                <xsl:variable name="state" as="item()+">
                  <xsl:choose>
                    <xsl:when test="$state[$p:error]">
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:when test="$state[$p:l1] = 32">                            <!-- '?' -->
                      <xsl:variable name="state" select="p:consume(32, $input, $state)"/> <!-- '?' -->
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$state"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse DocumentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DocumentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'document-node' -->
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' | 'element' | 'schema-element' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 49">                                  <!-- 'element' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-SchemaElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WhiteSpace | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DocumentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DocumentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PITest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaAttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 85">                                        <!-- 'text' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TextTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyKindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (40,                                          (: 'attribute' :)
                                         48,                                          (: 'document-node' :)
                                         49,                                          (: 'element' :)
                                         72,                                          (: 'node' :)
                                         78,                                          (: 'processing-instruction' :)
                                         81,                                          (: 'schema-attribute' :)
                                         82,                                          (: 'schema-element' :)
                                         85)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(13, $input, $state)"/>   <!-- EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' |
                                                                                         'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' | '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1704                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 1712                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 1713                                          (: 'element' '(' :)
                     or $state[$p:lk] = 1736                                          (: 'node' '(' :)
                     or $state[$p:lk] = 1742                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 1745                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 1746                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 1749">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 43">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(43, $input, $state)"/>       <!-- 'child' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'following' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WhiteSpace | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 40">                                       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead2W(15, $input, $state)"/>   <!-- EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | '::' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' |
                                                                                         'and' | 'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' |
                                                                                         '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (43,                                          (: 'child' :)
                                         45,                                          (: 'descendant' :)
                                         46,                                          (: 'descendant-or-self' :)
                                         55,                                          (: 'following' :)
                                         56,                                          (: 'following-sibling' :)
                                         70,                                          (: 'namespace' :)
                                         83)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(14, $input, $state)"/>   <!-- EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | '::' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' |
                                                                                         'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' | '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3368                                          (: 'attribute' '::' :)
                     or $state[$p:lk] = 3371                                          (: 'child' '::' :)
                     or $state[$p:lk] = 3373                                          (: 'descendant' '::' :)
                     or $state[$p:lk] = 3374                                          (: 'descendant-or-self' '::' :)
                     or $state[$p:lk] = 3383                                          (: 'following' '::' :)
                     or $state[$p:lk] = 3384                                          (: 'following-sibling' '::' :)
                     or $state[$p:lk] = 3398                                          (: 'namespace' '::' :)
                     or $state[$p:lk] = 3411">                                      <!-- 'self' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- Wildcard | QName^Token | S^WhiteSpace | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AxisStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AxisStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ForwardStep($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' |
                                                                                         'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' | '|' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AxisStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse StepExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StepExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AxisStep($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StepExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production RelativePathExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 23                                         (: '/' :)
                      and $state[$p:l1] != 24">                                     <!-- '//' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 23">                                <!-- '/' -->
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '/' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(24, $input, $state)"/> <!-- '//' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/> <!-- Wildcard | QName^Token | S^WhiteSpace | ('(' ':') | '@' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-StepExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-RelativePathExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse RelativePathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StepExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-RelativePathExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RelativePathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 23">                                        <!-- '/' -->
          <xsl:variable name="state" select="p:consume(23, $input, $state)"/>       <!-- '/' -->
          <xsl:variable name="state" select="p:lookahead1W(22, $input, $state)"/>   <!-- EOF | Wildcard | QName^Token | S^WhiteSpace | '!=' | ('(' ':') | ')' |
                                                                                         '*' | '+' | ',' | '-' | '<' | '<=' | '=' | '>' | '>=' | '@' | ']' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' | 'if' |
                                                                                         'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 2                                       (: EOF :)
                           or $state[$p:l1] = 12                                      (: '!=' :)
                           or $state[$p:l1] = 15                                      (: ')' :)
                           or $state[$p:l1] = 16                                      (: '*' :)
                           or $state[$p:l1] = 18                                      (: '+' :)
                           or $state[$p:l1] = 20                                      (: ',' :)
                           or $state[$p:l1] = 21                                      (: '-' :)
                           or $state[$p:l1] = 27                                      (: '&lt;' :)
                           or $state[$p:l1] = 28                                      (: '&lt;=' :)
                           or $state[$p:l1] = 29                                      (: '=' :)
                           or $state[$p:l1] = 30                                      (: '>' :)
                           or $state[$p:l1] = 31                                      (: '>=' :)
                           or $state[$p:l1] = 35                                      (: ']' :)
                           or $state[$p:l1] = 91">                                  <!-- '|' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-RelativePathExpr($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 24">                                        <!-- '//' -->
          <xsl:variable name="state" select="p:consume(24, $input, $state)"/>       <!-- '//' -->
          <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/>   <!-- Wildcard | QName^Token | S^WhiteSpace | ('(' ':') | '@' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'attribute' | 'cast' | 'castable' |
                                                                                         'child' | 'comment' | 'descendant' | 'descendant-or-self' | 'div' |
                                                                                         'document-node' | 'element' | 'else' | 'empty-sequence' | 'eq' |
                                                                                         'every' | 'except' | 'following' | 'following-sibling' | 'for' | 'ge' |
                                                                                         'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                         'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'node' | 'or' | 'parent' |
                                                                                         'preceding' | 'preceding-sibling' | 'processing-instruction' |
                                                                                         'return' | 'satisfies' | 'schema-attribute' | 'schema-element' |
                                                                                         'self' | 'some' | 'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Predicate.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Predicate" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(34, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(35, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Predicate', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PredicateList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>     <!-- EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' |
                                                                                         'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' | '|' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 34">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            "/>
            <xsl:sequence select="p:parse-PredicateList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PredicateList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PredicateList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PredicateList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 9">                                         <!-- QName^Token -->
          <xsl:variable name="state" select="p:consume(9, $input, $state)"/>        <!-- QName^Token -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 36">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(36, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 38">                                        <!-- 'and' -->
          <xsl:variable name="state" select="p:consume(38, $input, $state)"/>       <!-- 'and' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 41">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(41, $input, $state)"/>       <!-- 'cast' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 42">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(42, $input, $state)"/>       <!-- 'castable' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 43">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(43, $input, $state)"/>       <!-- 'child' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'div' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'div' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'else' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'else' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'every' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'except' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'except' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'following' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'for' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- 'for' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'ge' -->
          <xsl:variable name="state" select="p:consume(58, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 59">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'idiv' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'idiv' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'instance' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'intersect' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'intersect' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'mod' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'mod' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 70">                                        <!-- 'namespace' -->
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 71">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(71, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'or' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'or' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'parent' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'return' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'return' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 80">                                        <!-- 'satisfies' -->
          <xsl:variable name="state" select="p:consume(80, $input, $state)"/>       <!-- 'satisfies' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'to' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'treat' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'union' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production FunctionCall (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(20, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-FunctionCall-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse FunctionCall.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WhiteSpace | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | ')' | '+' |
                                                                                         '-' | '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' |
                                                                                         'and' | 'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-FunctionCall-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionCall', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ContextItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(22, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse GeneralComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-GeneralComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 29">                                        <!-- '=' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 12">                                        <!-- '!=' -->
          <xsl:variable name="state" select="p:consume(12, $input, $state)"/>       <!-- '!=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '<' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 28">                                        <!-- '<=' -->
          <xsl:variable name="state" select="p:consume(28, $input, $state)"/>       <!-- '<=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 30">                                        <!-- '>' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(31, $input, $state)"/>       <!-- '>=' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'GeneralComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 16                                         (: '*' :)
                      and $state[$p:l1] != 47                                         (: 'div' :)
                      and $state[$p:l1] != 69">                                     <!-- 'mod' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 16">                                <!-- '*' -->
                  <xsl:variable name="state" select="p:consume(16, $input, $state)"/> <!-- '*' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 47">                                <!-- 'div' -->
                  <xsl:variable name="state" select="p:consume(47, $input, $state)"/> <!-- 'div' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(69, $input, $state)"/> <!-- 'mod' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnionExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-MultiplicativeExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MultiplicativeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-MultiplicativeExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MultiplicativeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AdditiveExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 18                                         (: '+' :)
                      and $state[$p:l1] != 21">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 18">                                <!-- '+' -->
                  <xsl:variable name="state" select="p:consume(18, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MultiplicativeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AdditiveExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AdditiveExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MultiplicativeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AdditiveExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AdditiveExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ComparisonExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ComparisonExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AdditiveExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15                                           (: ')' :)
                    and $state[$p:l1] != 20                                           (: ',' :)
                    and $state[$p:l1] != 35                                           (: ']' :)
                    and $state[$p:l1] != 38                                           (: 'and' :)
                    and $state[$p:l1] != 74">                                       <!-- 'or' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ComparisonExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AndExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 38">                                     <!-- 'and' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(38, $input, $state)"/>     <!-- 'and' -->
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ComparisonExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AndExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AndExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ComparisonExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AndExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AndExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production OrExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 74">                                     <!-- 'or' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(74, $input, $state)"/>     <!-- 'or' -->
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AndExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-OrExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse OrExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AndExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-OrExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OrExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ExprSingle.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ExprSingle" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-OrExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ExprSingle', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Expr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Expr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(13, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | ')' | '+' |
                                                                                         '-' | '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' |
                                                                                         'and' | 'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 15">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NumericLiteral.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NumericLiteral" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 4">                                         <!-- DecimalLiteral -->
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- DecimalLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- DoubleLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NumericLiteral', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Literal.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Literal" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NumericLiteral($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Literal', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PrimaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PrimaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3                                             (: IntegerLiteral :)
                     or $state[$p:l1] = 4                                             (: DecimalLiteral :)
                     or $state[$p:l1] = 5                                             (: DoubleLiteral :)
                     or $state[$p:l1] = 6">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Literal($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 13">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 22">                                        <!-- '.' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ContextItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionCall($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PrimaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FilterExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FilterExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PrimaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>         <!-- EOF | S^WhiteSpace | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' | 'div' | 'except' |
                                                                                         'intersect' | 'mod' | 'or' | 'union' | '|' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FilterExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (43,                                          (: 'child' :)
                                         45,                                          (: 'descendant' :)
                                         46,                                          (: 'descendant-or-self' :)
                                         55,                                          (: 'following' :)
                                         56,                                          (: 'following-sibling' :)
                                         70,                                          (: 'namespace' :)
                                         83)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(15, $input, $state)"/>   <!-- EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | '::' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' |
                                                                                         'and' | 'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' |
                                                                                         '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (9,                                           (: QName^Token :)
                                         36,                                          (: 'ancestor' :)
                                         37,                                          (: 'ancestor-or-self' :)
                                         38,                                          (: 'and' :)
                                         41,                                          (: 'cast' :)
                                         42,                                          (: 'castable' :)
                                         47,                                          (: 'div' :)
                                         50,                                          (: 'else' :)
                                         52,                                          (: 'eq' :)
                                         53,                                          (: 'every' :)
                                         54,                                          (: 'except' :)
                                         57,                                          (: 'for' :)
                                         58,                                          (: 'ge' :)
                                         59,                                          (: 'gt' :)
                                         60,                                          (: 'idiv' :)
                                         63,                                          (: 'instance' :)
                                         64,                                          (: 'intersect' :)
                                         65,                                          (: 'is' :)
                                         67,                                          (: 'le' :)
                                         68,                                          (: 'lt' :)
                                         69,                                          (: 'mod' :)
                                         71,                                          (: 'ne' :)
                                         74,                                          (: 'or' :)
                                         75,                                          (: 'parent' :)
                                         76,                                          (: 'preceding' :)
                                         77,                                          (: 'preceding-sibling' :)
                                         79,                                          (: 'return' :)
                                         80,                                          (: 'satisfies' :)
                                         84,                                          (: 'some' :)
                                         87,                                          (: 'to' :)
                                         88,                                          (: 'treat' :)
                                         90)">                                      <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(13, $input, $state)"/>   <!-- EOF | S^WhiteSpace | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | '<' | '<=' | '=' | '>' | '>=' | '[' | ']' | 'and' |
                                                                                         'div' | 'except' | 'intersect' | 'mod' | 'or' | 'union' | '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 4                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 5                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 6                                             (: StringLiteral :)
                     or $state[$p:lk] = 13                                            (: '(' :)
                     or $state[$p:lk] = 22                                            (: '.' :)
                     or $state[$p:lk] = 1673                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 1700                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 1701                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 1702                                          (: 'and' '(' :)
                     or $state[$p:lk] = 1705                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 1706                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 1707                                          (: 'child' '(' :)
                     or $state[$p:lk] = 1709                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 1710                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 1711                                          (: 'div' '(' :)
                     or $state[$p:lk] = 1714                                          (: 'else' '(' :)
                     or $state[$p:lk] = 1716                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 1717                                          (: 'every' '(' :)
                     or $state[$p:lk] = 1718                                          (: 'except' '(' :)
                     or $state[$p:lk] = 1719                                          (: 'following' '(' :)
                     or $state[$p:lk] = 1720                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 1721                                          (: 'for' '(' :)
                     or $state[$p:lk] = 1722                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 1723                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 1724                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 1727                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 1728                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 1729                                          (: 'is' '(' :)
                     or $state[$p:lk] = 1731                                          (: 'le' '(' :)
                     or $state[$p:lk] = 1732                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 1733                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 1734                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 1735                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 1738                                          (: 'or' '(' :)
                     or $state[$p:lk] = 1739                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 1740                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 1741                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 1743                                          (: 'return' '(' :)
                     or $state[$p:lk] = 1744                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 1747                                          (: 'self' '(' :)
                     or $state[$p:lk] = 1748                                          (: 'some' '(' :)
                     or $state[$p:lk] = 1751                                          (: 'to' '(' :)
                     or $state[$p:lk] = 1752                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 1754">                                      <!-- 'union' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FilterExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnaryExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>     <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 18                                         (: '+' :)
                      and $state[$p:l1] != 21">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 21">                                <!-- '-' -->
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(18, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-UnaryExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-UnaryExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 54                                         (: 'except' :)
                      and $state[$p:l1] != 64">                                     <!-- 'intersect' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 64">                                <!-- 'intersect' -->
                  <xsl:variable name="state" select="p:consume(64, $input, $state)"/> <!-- 'intersect' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(54, $input, $state)"/> <!-- 'except' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnaryExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-IntersectExceptExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse IntersectExceptExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-IntersectExceptExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IntersectExceptExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnionExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 90                                         (: 'union' :)
                      and $state[$p:l1] != 91">                                     <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 90">                                <!-- 'union' -->
                  <xsl:variable name="state" select="p:consume(90, $input, $state)"/> <!-- 'union' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(91, $input, $state)"/> <!-- '|' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-IntersectExceptExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-UnionExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-IntersectExceptExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-UnionExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse XPath.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-XPath" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         Wildcard | QName^Token | S^WhiteSpace | '(' | ('(' ':') | '+' | '-' |
                                                                                         '.' | '/' | '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'lt' | 'mod' |
                                                                                         'namespace' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                         'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                         'satisfies' | 'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(2, $input, $state)"/>              <!-- EOF -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'XPath', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 6),
          0, 0, 0,
          subsequence($state, 10),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state. In contrast to p:consume, do not create any output.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consumeT" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:sequence select="
          subsequence($state, $p:l1, 6),
          0, 0, 0,
          subsequence($state, 10)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 10">                                              <!-- S^WhiteSpace -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:when test="$match[1] = 14">                                              <!-- ('(' ':') -->
        <xsl:variable name="state" select="p:try-WhiteSpace($input, (0, $begin, $begin, $match, 0, 0, 0, false()))"/>
        <xsl:sequence select="p:matchW($input, $state[$p:e0], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 3)
      else
        p:matchW($input, $state[$p:e1], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 10)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol XPath from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-XPath" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-XPath($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse start symbol OccurrenceIndicator from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-OccurrenceIndicator($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse start symbol ItemType from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-ItemType" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-ItemType($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>